{"version":3,"file":"popup.js","mappings":"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","sources":["webpack://context-focus/./src/api/storageApi.ts","webpack://context-focus/webpack/bootstrap","webpack://context-focus/./src/popup/popup.ts"],"sourcesContent":["import { FocusSettings, StorageData as TypesStorageData, FocusState } from \"../types/index\";\n\n// Re-export the StorageData interface from types/index.d.ts\nexport type StorageData = TypesStorageData;\n\n/**\n * Get an object containing the requested keys.\n */\nexport function getStorage<T extends keyof StorageData>(\n  keys: T[]\n): Promise<Pick<StorageData, T>> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.get(keys, (result) => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve(result as Pick<StorageData, T>);\n    });\n  });\n}\n\n/**\n * Set or update the given keys in storage.\n */\nexport function setStorage(data: Partial<StorageData>): Promise<void> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.set(data, () => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * Add a context entry to history\n */\nexport async function addContextToHistory(\n  context: string,\n  url: string,\n  confidence: number\n): Promise<void> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  const newHistory = contextHistory || [];\n  \n  // Add new entry\n  newHistory.push({\n    context,\n    url,\n    timestamp: Date.now(),\n    confidence\n  });\n  \n  // Limit history size\n  if (newHistory.length > 100) {\n    newHistory.shift();\n  }\n  \n  await setStorage({ contextHistory: newHistory });\n}\n\n/**\n * Get the current focus state\n */\nexport async function getFocusState(): Promise<FocusState> {\n  const { focusState } = await getStorage([\"focusState\"]);\n  \n  // Default state if none exists\n  const defaultState: FocusState = {\n    active: false,\n    allowedContexts: []\n  };\n  \n  return { ...defaultState, ...focusState };\n}\n\n/**\n * Update the focus state\n */\nexport async function setFocusState(partialState: Partial<FocusState>): Promise<void> {\n  const currentState = await getFocusState();\n  await setStorage({ \n    focusState: { ...currentState, ...partialState }\n  });\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Simplified popup for the Focus extension\n * \n * This popup allows users to select which contexts they want to focus on\n * and optionally set a timer duration. Everything else is blocked.\n */\n\nimport { getFocusState } from \"../api/storageApi\";\n\n// DOM Elements\nconst inactiveUI = document.getElementById('inactiveUI') as HTMLElement;\nconst activeUI = document.getElementById('activeUI') as HTMLElement;\nconst contextList = document.getElementById('contextList') as HTMLElement;\nconst durationInput = document.getElementById('duration') as HTMLInputElement;\nconst startBtn = document.getElementById('startBtn') as HTMLButtonElement;\nconst endBtn = document.getElementById('endBtn') as HTMLButtonElement;\nconst allowedTags = document.getElementById('allowedTags') as HTMLElement;\nconst countdown = document.getElementById('countdown') as HTMLElement;\n\n// Available contexts\nconst AVAILABLE_CONTEXTS = [\n  'Work',\n  'Development',\n  'Research',\n  'Learning',\n  'Entertainment',\n  'Social', \n  'Shopping',\n  'News'\n];\n\n// Initialize the popup\nasync function initPopup() {\n  // Render context checkboxes\n  renderContextList();\n  \n  // Check current focus state\n  const focusState = await getFocusState();\n  \n  if (focusState.active) {\n    // Show active UI\n    renderActive(focusState);\n  } else {\n    // Show inactive UI\n    renderInactive();\n  }\n  \n  // Setup event listeners\n  setupEventListeners();\n  \n  // Start polling for updates (to update the countdown)\n  startPolling();\n}\n\n// Render the list of contexts as checkboxes\nfunction renderContextList() {\n  contextList.innerHTML = '';\n  \n  AVAILABLE_CONTEXTS.forEach(context => {\n    const wrapper = document.createElement('div');\n    wrapper.className = 'context-checkbox';\n    \n    const input = document.createElement('input');\n    input.type = 'checkbox';\n    input.value = context;\n    input.id = `context-${context}`;\n    input.className = 'context-checkbox-input';\n    \n    const label = document.createElement('label');\n    label.textContent = context;\n    label.htmlFor = `context-${context}`;\n    \n    wrapper.appendChild(input);\n    wrapper.appendChild(label);\n    contextList.appendChild(wrapper);\n  });\n}\n\n// Show the inactive UI (start focus)\nfunction renderInactive() {\n  inactiveUI.hidden = false;\n  activeUI.hidden = true;\n}\n\n// Show the active UI (end focus)\nfunction renderActive(focusState: any) {\n  inactiveUI.hidden = true;\n  activeUI.hidden = false;\n  \n  // Show allowed contexts\n  allowedTags.textContent = focusState.allowedContexts.join(', ');\n  \n  // Show countdown if there's a timer\n  updateCountdown(focusState);\n}\n\n// Update the countdown timer\nfunction updateCountdown(focusState: any) {\n  if (!focusState.endTime) {\n    countdown.textContent = 'No time limit';\n    return;\n  }\n  \n  const now = Date.now();\n  const timeLeft = Math.max(0, focusState.endTime - now);\n  \n  if (timeLeft <= 0) {\n    countdown.textContent = 'Time expired';\n    return;\n  }\n  \n  // Format as MM:SS\n  const minutes = Math.floor(timeLeft / 60000);\n  const seconds = Math.floor((timeLeft % 60000) / 1000);\n  \n  countdown.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} remaining`;\n}\n\n// Setup event listeners\nfunction setupEventListeners() {\n  // Start Focus button\n  startBtn.addEventListener('click', () => {\n    // Get selected contexts\n    const selectedCheckboxes = document.querySelectorAll<HTMLInputElement>('.context-checkbox-input:checked');\n    const allowedContexts = Array.from(selectedCheckboxes).map(cb => cb.value);\n    \n    if (allowedContexts.length === 0) {\n      alert('Please select at least one context to focus on');\n      return;\n    }\n    \n    // Get duration (if any)\n    const duration = durationInput.value ? parseInt(durationInput.value, 10) : undefined;\n    \n    // Calculate blocked categories\n    const blockedCategories = AVAILABLE_CONTEXTS.filter(c => !allowedContexts.includes(c));\n    \n    // Start focus session with correct format\n    chrome.runtime.sendMessage({\n      type: 'START_FOCUS_SESSION',\n      payload: {\n        blockedCategories: blockedCategories,\n        durationMinutes: duration\n      }\n    }, () => {\n      // Refresh the popup after starting\n      window.location.reload();\n    });\n  });\n  \n  // End Focus button\n  endBtn.addEventListener('click', () => {\n    chrome.runtime.sendMessage({\n      type: 'END_FOCUS_SESSION'\n    }, () => {\n      // Refresh the popup after ending\n      window.location.reload();\n    });\n  });\n}\n\n// Poll for updates (for countdown)\nfunction startPolling() {\n  setInterval(async () => {\n    const focusState = await getFocusState();\n    \n    if (focusState.active && !activeUI.hidden) {\n      updateCountdown(focusState);\n    }\n  }, 1000);\n}\n\n// Initialize when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', initPopup);"],"names":["getStorage","keys","Promise","resolve","reject","chrome","storage","local","get","result","runtime","lastError","setStorage","data","set","async","getFocusState","focusState","active","allowedContexts","context","url","confidence","contextHistory","newHistory","push","timestamp","Date","now","length","shift","partialState","currentState","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","inactiveUI","document","getElementById","activeUI","contextList","durationInput","startBtn","endBtn","allowedTags","countdown","AVAILABLE_CONTEXTS","updateCountdown","endTime","textContent","timeLeft","Math","max","minutes","floor","seconds","toString","padStart","addEventListener","innerHTML","forEach","wrapper","createElement","className","input","type","value","id","label","htmlFor","appendChild","hidden","join","renderActive","selectedCheckboxes","querySelectorAll","Array","from","map","cb","alert","duration","parseInt","blockedCategories","filter","c","includes","sendMessage","payload","durationMinutes","window","location","reload","setInterval"],"sourceRoot":""}