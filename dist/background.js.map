{"version":3,"file":"background.js","mappings":"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","sources":["webpack://context-focus/./src/api/storageApi.ts","webpack://context-focus/./src/lib/windows/focusWindow.ts","webpack://context-focus/./src/lib/pickColor.ts","webpack://context-focus/./src/lib/focusEngine.ts","webpack://context-focus/./src/lib/panels/sidePanelManager.ts","webpack://context-focus/./src/background/index.ts","webpack://context-focus/./src/api/parkedLinksApi.ts","webpack://context-focus/./src/api/tabsApi.ts","webpack://context-focus/./src/api/focusApi.ts","webpack://context-focus/webpack/bootstrap","webpack://context-focus/webpack/startup"],"sourcesContent":["import { FocusSettings, StorageData as TypesStorageData, FocusState } from \"../types/index\";\n\n// Re-export the StorageData interface from types/index.d.ts\nexport type StorageData = TypesStorageData;\n\n/**\n * Get an object containing the requested keys.\n */\nexport function getStorage<T extends keyof StorageData>(\n  keys: T[]\n): Promise<Pick<StorageData, T>> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.get(keys, (result) => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve(result as Pick<StorageData, T>);\n    });\n  });\n}\n\n/**\n * Set or update the given keys in storage.\n */\nexport function setStorage(data: Partial<StorageData>): Promise<void> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.set(data, () => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * Add a context entry to history\n */\nexport async function addContextToHistory(\n  context: string,\n  url: string,\n  confidence: number\n): Promise<void> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  const newHistory = contextHistory || [];\n  \n  // Add new entry\n  newHistory.push({\n    context,\n    url,\n    timestamp: Date.now(),\n    confidence\n  });\n  \n  // Limit history size\n  if (newHistory.length > 100) {\n    newHistory.shift();\n  }\n  \n  await setStorage({ contextHistory: newHistory });\n}\n\n/**\n * Get the current focus state\n */\nexport async function getFocusState(): Promise<FocusState> {\n  const { focusState } = await getStorage([\"focusState\"]);\n  \n  // Default state if none exists\n  const defaultState: FocusState = {\n    active: false,\n    allowedContexts: []\n  };\n  \n  return { ...defaultState, ...focusState };\n}\n\n/**\n * Update the focus state\n */\nexport async function setFocusState(partialState: Partial<FocusState>): Promise<void> {\n  const currentState = await getFocusState();\n  await setStorage({ \n    focusState: { ...currentState, ...partialState }\n  });\n}","let focusWindowId: number | undefined;\n\n/**\n * Create a dedicated window for the focus session\n * This creates a new window that can be populated with productive tabs\n */\nexport async function launchFocusWindow(): Promise<number | undefined> {\n  try {\n    // Check if focus window already exists\n    if (focusWindowId !== undefined) {\n      try {\n        // Try to get window to verify it still exists\n        await chrome.windows.get(focusWindowId);\n        return focusWindowId; // Window already exists\n      } catch (error) {\n        // Window doesn't exist anymore, reset the ID\n        focusWindowId = undefined;\n      }\n    }\n\n    // Create a new window\n    const { id } = await chrome.windows.create({\n      url: \"about:blank\",\n      type: \"normal\",\n      state: \"maximized\"\n    });\n    \n    focusWindowId = id;\n    \n    // Create a welcoming tab\n    if (id) {\n      const tabs = await chrome.tabs.query({ windowId: id });\n      \n      // If there's at least one tab (the default about:blank), update it\n      if (tabs.length > 0 && tabs[0].id) {\n        await chrome.tabs.update(tabs[0].id, { \n          url: chrome.runtime.getURL(\"blocked.html\") + \"?mode=welcome\" \n        });\n      }\n    }\n    \n    return focusWindowId;\n  } catch (error) {\n    console.error(\"Error launching focus window:\", error);\n    return undefined;\n  }\n}\n\n/**\n * Close the dedicated focus window\n */\nexport async function closeFocusWindow(): Promise<void> {\n  if (focusWindowId === undefined) return;\n  \n  try {\n    await chrome.windows.remove(focusWindowId);\n    focusWindowId = undefined;\n  } catch (error) {\n    console.error(\"Error closing focus window:\", error);\n    // Reset the ID even if there was an error\n    focusWindowId = undefined;\n  }\n}\n\n/**\n * Check if the focus window is active\n */\nexport function getFocusWindowId(): number | undefined {\n  return focusWindowId;\n}\n\n/**\n * Move a tab to the focus window\n */\nexport async function moveTabToFocusWindow(tabId: number): Promise<boolean> {\n  if (focusWindowId === undefined) {\n    const windowId = await launchFocusWindow();\n    if (windowId === undefined) return false;\n  }\n  \n  try {\n    await chrome.tabs.move(tabId, { windowId: focusWindowId!, index: -1 });\n    return true;\n  } catch (error) {\n    console.error(\"Error moving tab to focus window:\", error);\n    return false;\n  }\n} ","export function pickColorForContext(context: string): chrome.tabGroups.ColorEnum {\n  switch (context) {\n    case \"Work\":\n      return \"yellow\";\n    case \"Learning\":\n      return \"blue\";\n    case \"Entertainment\":\n      return \"green\";\n    case \"News\":\n      return \"red\";\n    case \"Shopping\":\n      return \"purple\";\n    case \"Social\":\n      return \"cyan\";\n    case \"Research\":\n      return \"pink\";\n    case \"Development\":\n      return \"orange\";\n    default:\n      return \"grey\";  // Chrome uses \"grey\" (British spelling) not \"gray\"\n  }\n}","/**\n * Focus Engine - Core logic for the Focus feature\n * \n * This module implements the state machine for focus mode, following the principle\n * of \"block by exclusion\" - where user picks ALLOWED contexts and everything else is blocked.\n */\n\nimport { getFocusState, setFocusState, getStorage, setStorage } from \"../api/storageApi\";\nimport { FocusState } from \"../types/index\";\nimport { openSidePanel, closeSidePanel } from \"../lib/panels/sidePanelManager\";\nimport { launchFocusWindow, closeFocusWindow } from \"../lib/windows/focusWindow\";\nimport { releaseParkedLinks } from \"../api/parkedLinksApi\";\nimport { ungroupAllTabs } from \"../api/tabsApi\";\n\n// State for tracking if a navigation was blocked recently (for badge alert)\nlet recentlyBlocked = false;\nlet blockClearTimer: NodeJS.Timeout | undefined;\n\n/**\n * Start a focus session\n * \n * @param allowed - Array of context categories that are allowed during focus\n * @param durationMin - Optional duration in minutes after which focus will automatically end\n */\nexport async function start(allowed: string[], durationMin?: number): Promise<void> {\n  // Safety check for allowed contexts\n  const safeAllowed = Array.isArray(allowed) ? allowed : [];\n  \n  // Calculate end time if duration is provided\n  const endTime = durationMin ? Date.now() + durationMin * 60 * 1000 : undefined;\n  \n  // Save focus state\n  await setFocusState({\n    active: true,\n    allowedContexts: safeAllowed,\n    endTime\n  });\n  \n  // Store blockedCategories for backward compatibility\n  const knownContexts = [\n    \"Work\", \"Development\", \"Research\", \"Learning\", \n    \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n  ];\n  const blockedCategories = knownContexts.filter(ctx => !safeAllowed.includes(ctx));\n  await setStorage({ blockedCategories });\n  \n  // Open the side panel for persistent timer display\n  await openSidePanel();\n  \n  // Check if focus window is enabled and launch if needed\n  const storage = await getStorage([\"focusSettings\"]);\n  const focusWindowEnabled = storage.focusSettings?.focusWindowEnabled || false;\n  if (focusWindowEnabled) {\n    await launchFocusWindow();\n  }\n  \n  // Set badge to show focus is active\n  chrome.action.setBadgeText({ text: \"•\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n  \n  // Show notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Started',\n    message: durationMin ? \n      `Focus session started for ${durationMin} minutes. Stay focused!` :\n      'Focus session started. Stay focused!',\n    priority: 2\n  });\n}\n\n/**\n * End a focus session\n * @param saveWorkspaceName - Optional workspace name to save current tab groups\n */\nexport async function end(saveWorkspaceName?: string): Promise<void> {\n  // If user wants to save workspace, store it\n  if (saveWorkspaceName) {\n    try {\n      // Get all tab groups\n      const groups = await chrome.tabGroups.query({});\n      // For each group, gather tab URLs\n      const workspaceGroups = await Promise.all(\n        groups.map(async (grp) => {\n          const tabs = await chrome.tabs.query({ groupId: grp.id });\n          return {\n            groupId: grp.id,\n            title: grp.title || \"\",\n            color: grp.color,\n            tabUrls: tabs.map(t => t.url || \"\")\n          };\n        })\n      );\n\n      // Store in savedWorkspaces\n      const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n      const newWorkspaceEntry = {\n        name: saveWorkspaceName,\n        tabGroups: workspaceGroups,\n        timestamp: Date.now()\n      };\n\n      const updatedWorkspaces = Array.isArray(savedWorkspaces) \n        ? [...savedWorkspaces, newWorkspaceEntry]\n        : [newWorkspaceEntry];\n\n      await setStorage({ savedWorkspaces: updatedWorkspaces });\n    } catch (error) {\n      console.error(\"Error saving workspace:\", error);\n    }\n  }\n  \n  // Clear focus state\n  await setFocusState({\n    active: false,\n    endTime: undefined\n  });\n  \n  // Close UI components\n  await closeSidePanel();\n  await closeFocusWindow();\n  await ungroupAllTabs();\n  \n  // Clear badge\n  chrome.action.setBadgeText({ text: \"\" });\n  \n  // Reset block indicator\n  recentlyBlocked = false;\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n    blockClearTimer = undefined;\n  }\n  \n  // Show notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Ended',\n    message: 'Your focus session has ended. Great job!',\n    priority: 2\n  });\n  \n  // Release any links that were parked during the session\n  await releaseParkedLinks();\n}\n\n/**\n * Check if a context should be blocked\n * \n * @param context - The context category to check\n * @returns true if the context should be blocked, false otherwise\n */\nexport async function isBlocked(context: string): Promise<boolean> {\n  const focusState = await getFocusState();\n  \n  // If focus is not active, nothing is blocked\n  if (!focusState.active) {\n    return false;\n  }\n  \n  // Safety check: ensure allowedContexts is an array before using includes\n  if (!Array.isArray(focusState.allowedContexts)) {\n    console.error(\"[FocusEngine] allowedContexts is not an array:\", focusState.allowedContexts);\n    return false; // Fail open rather than blocking everything\n  }\n  \n  // Add logging to help debug\n  console.log(\"[FocusEngine] allowed:\", focusState.allowedContexts, \"context:\", context);\n  \n  // If context is in allowed list, it's not blocked\n  if (focusState.allowedContexts.includes(context)) {\n    return false;\n  }\n  \n  // Context is not in allowed list, so it's blocked\n  // Update the \"recently blocked\" state for badge\n  recentlyBlocked = true;\n  \n  // Show red \"!\" badge\n  chrome.action.setBadgeText({ text: \"!\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red\n  \n  // Clear the blocked indicator after 30 seconds\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n  }\n  \n  blockClearTimer = setTimeout(() => {\n    if (recentlyBlocked) {\n      recentlyBlocked = false;\n      // Restore the normal focus badge\n      chrome.action.setBadgeText({ text: \"•\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n    }\n  }, 30000);\n  \n  return true;\n}\n\n/**\n * Check if a focus session is currently active\n * \n * @returns true if a focus session is active, false otherwise\n */\nexport async function isActive(): Promise<boolean> {\n  const focusState = await getFocusState();\n  return focusState.active;\n}\n\n/**\n * Get the time left in the current focus session in seconds\n * \n * @returns Seconds left in the focus session, or -1 if no timer (unlimited session)\n */\nexport async function getTimeLeft(): Promise<number> {\n  const { active, endTime } = await getFocusState();\n  if (!active) return 0; // Not active, no time\n  if (!endTime) return -1; // -1 = unlimited/indefinite session\n  return Math.max(0, endTime - Date.now()) / 1000; // seconds\n}\n\n/**\n * Restore a saved workspace by name. \n * Re-open tabs and re-create groups (approximation).\n */\nexport async function restoreWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const workspace = savedWorkspaces.find(ws => ws.name === name);\n  if (!workspace) return;\n\n  // For each group, re-create tabs\n  for (const grp of workspace.tabGroups) {\n    // Open each tab\n    const tabIds = [];\n    for (const url of grp.tabUrls) {\n      const createdTab = await chrome.tabs.create({ url, active: false });\n      tabIds.push(createdTab.id as number);\n    }\n    // Create or update tab group\n    if (tabIds.length > 0) {\n      const newGroupId = await chrome.tabs.group({ tabIds });\n      await chrome.tabGroups.update(newGroupId, {\n        title: grp.title || \"\",\n        color: grp.color\n      });\n    }\n  }\n}\n\n/**\n * Save current window's tab groups (workspace).\n * This can be called at the end of a Focus Session or on demand.\n */\nexport async function saveCurrentWorkspace(name: string): Promise<void> {\n  // Get all tab groups\n  const groups = await chrome.tabGroups.query({});\n  // For each group, gather tab URLs\n  const workspaceGroups = await Promise.all(\n    groups.map(async (grp) => {\n      const tabs = await chrome.tabs.query({ groupId: grp.id });\n      return {\n        groupId: grp.id,\n        title: grp.title || \"\",\n        color: grp.color,\n        tabUrls: tabs.map(t => t.url || \"\")\n      };\n    })\n  );\n\n  // Store in savedWorkspaces\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  const newWorkspaceEntry = {\n    name,\n    tabGroups: workspaceGroups,\n    timestamp: Date.now()\n  };\n\n  const updatedWorkspaces = Array.isArray(savedWorkspaces) \n    ? [...savedWorkspaces, newWorkspaceEntry]\n    : [newWorkspaceEntry];\n\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n}\n\n/**\n * Clean up old workspace entries if needed, or remove a workspace by name, etc.\n */\nexport async function removeWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const updatedWorkspaces = savedWorkspaces.filter(ws => ws.name !== name);\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n} ","/**\n * Open the side panel in the current window\n */\nexport async function openSidePanel(): Promise<void> {\n  try {\n    const currentWindow = await chrome.windows.getCurrent();\n    await chrome.sidePanel.open({ windowId: currentWindow.id });\n    console.log(\"Side panel opened successfully\");\n  } catch (error) {\n    console.error(\"Error opening side panel:\", error);\n  }\n}\n\n/**\n * Close the side panel in all windows\n */\nexport async function closeSidePanel(): Promise<void> {\n  try {\n    const panels = await chrome.sidePanel.getAll();\n    await Promise.all(panels.map((panel: chrome.sidePanel.PanelInfo) => \n      chrome.sidePanel.close({ windowId: panel.windowId })\n    ));\n    console.log(\"Side panels closed successfully\");\n  } catch (error) {\n    console.error(\"Error closing side panels:\", error);\n  }\n}\n\n/**\n * Set the side panel properties\n */\nexport async function setSidePanelProperties(path: string, title: string): Promise<void> {\n  try {\n    await chrome.sidePanel.setOptions({\n      path,\n      enabled: true\n    });\n    console.log(\"Side panel properties updated\");\n  } catch (error) {\n    console.error(\"Error setting side panel properties:\", error);\n  }\n} ","import { groupTabByContext, onTabRemoved, ungroupAllTabs } from \"../api/tabsApi\";\nimport { getStorage, setStorage, getFocusState, setFocusState } from \"../api/storageApi\";\nimport { checkFocusStatus, showFocusNotification } from \"../api/focusApi\";\nimport { classifyPageContext } from \"../lib/contextEngine\";\nimport { extractDomain } from \"../lib/contextEngine/urlAnalyzer\";\nimport { saveForLater, releaseParkedLinks, goBackOrClose } from \"../api/parkedLinksApi\";\nimport * as focusEngine from \"../lib/focusEngine\";\n\nconst tabContextMap: Record<number, string> = {};\nconst BLOCKED_PAGE_URL = chrome.runtime.getURL(\"blocked.html\");\n\n/**\n * Initialize the extension with proper default settings\n */\nasync function initExtension(): Promise<void> {\n  // Always enable the extension\n  await setStorage({ extensionEnabled: true });\n  \n  console.log(\"[Background] Extension enabled.\");\n  \n  // Check for active sessions - now using the new focusState\n  const focusState = await getFocusState();\n  if (focusState.active) {\n    console.log(\"[Background] Focus session was active at shutdown, verifying...\");\n    // Verify session is still valid (not expired)\n    if (!focusState.endTime || focusState.endTime <= Date.now()) {\n      console.log(\"[Background] Focus session expired during shutdown, cleaning up\");\n      await setFocusState({ active: false, endTime: undefined });\n    } else {\n      console.log(`[Background] Focus session continues until ${new Date(focusState.endTime).toLocaleTimeString()}`);\n    }\n  }\n  \n  // Setup URL blocking for Focus Session - always setup the handler\n  setupFocusSessionUrlBlocking();\n  \n  // Set up periodic checks\n  setupPeriodicChecks();\n}\n\n/**\n * Set up all periodic checks needed for the extension\n */\nfunction setupPeriodicChecks() {\n  // Set up alarms for periodic checks - minimum 1 minute for MV3\n  chrome.alarms.create('focusTick', { periodInMinutes: 1 });     // 60s - check session status\n  chrome.alarms.create('focusDrift', { periodInMinutes: 2 });    // 120s - check drift (less urgent)\n  \n  // Handle alarms\n  chrome.alarms.onAlarm.addListener(async ({ name }) => {\n    try {\n      if (name === 'focusTick') {\n        await checkFocusSessionStatus();\n      } else if (name === 'focusDrift') {\n        const isSessionActive = await focusEngine.isActive();\n        if (isSessionActive) {\n          const focusStatus = await checkFocusStatus();\n          if (focusStatus.isLostFocus) {\n            // Immediately send a drift warning if focus is lost\n            await sendDriftWarning(focusStatus);\n          }\n        }\n      }\n      // Update badge for all alarm types\n      await updateBadge();\n    } catch (err) {\n      console.error(`Error in alarm handler (${name}):`, err);\n    }\n  });\n}\n\n/**\n * Handle messages from content scripts and the UI\n */\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.type === \"CONTEXT_UPDATE\" || request.type === \"CONTEXT_DETECTED\") {\n    const context = request.context as string;\n    const tabId = sender.tab?.id;\n    \n    if (tabId != null) {\n      // Check if context has changed\n      const previousContext = tabContextMap[tabId];\n      if (previousContext !== context) {\n        // Notify focus mode about context change\n        // handleContextChange(context);\n      }\n      \n      tabContextMap[tabId] = context;\n      \n      // Store additional context data if available\n      const contextData = {\n        context,\n        confidence: request.confidence,\n        secondaryContexts: request.secondaryContexts,\n        url: request.url\n      };\n      \n      // Save context data to storage for URL blocking functionality\n      chrome.storage.local.set({\n        [request.url]: { context: request.context, confidence: request.confidence }\n      });\n      \n      // Handle the context update\n      handleContextUpdate(tabId, context, contextData).catch((err) => console.error(err));\n    }\n    \n    return false; // No response needed\n  } \n  else if (request.type === \"FOCUS_TOGGLE\") {\n    toggleFocusMode(request.enabled).catch((err) => console.error(err));\n    return false; // No response needed\n  }\n  else if (request.type === \"START_FOCUS_SESSION\") {\n    const { durationMinutes, blockedCategories } = request.payload || {};\n    \n    const KNOWN_CONTEXTS = [\n      \"Work\", \"Development\", \"Research\", \"Learning\",\n      \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n    ];\n    const allowedContexts = KNOWN_CONTEXTS.filter(\n      ctx => !blockedCategories?.includes(ctx)\n    );\n    \n    focusEngine.start(allowedContexts, durationMinutes)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Indicates async response\n  }\n  else if (request.type === \"END_FOCUS_SESSION\") {\n    const { saveWorkspaceName } = request.payload || {};\n    focusEngine.end(saveWorkspaceName)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(\"Error ending focus session:\", err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"GET_FOCUS_TIME_LEFT\") {\n    focusEngine.getTimeLeft()\n      .then(seconds => {\n        sendResponse({ seconds });\n      })\n      .catch(error => {\n        console.error(\"Error getting focus time left:\", error);\n        sendResponse({ seconds: 0 });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"OVERRIDE_BLOCK\") {\n    // Allow explicit override\n    // Just respond with success, this would unblock the tab \n    // if we had a temporary block list\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"RESTORE_WORKSPACE\") {\n    const { name } = request.payload || {};\n    focusEngine.restoreWorkspace(name)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Indicates async response\n  }\n  else if (request.type === \"CHECK_FOCUS_STATUS\") {\n    checkFocusStatus()\n      .then(result => sendResponse(result))\n      .catch(error => {\n        console.error(\"Error checking focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"CONTENT_SCRIPT_READY\") {\n    // Content script is ready to receive messages\n    const tabId = sender.tab?.id;\n    // if (tabId && activeTimer && activeTimer.active && activeTimer.endTime > Date.now()) {\n    //   console.log(`Tab ${tabId} is ready, sending active timer`);\n    //   // Send the timer right away\n    //   chrome.tabs.sendMessage(tabId, {\n    //     type: \"RESTORE_FOCUS_TIMER\",\n    //     timerState: activeTimer\n    //   }).catch(err => {\n    //     console.log('Tab not fully ready, will retry');\n    //     // Try again after a short delay\n    //     setTimeout(() => {\n    //       chrome.tabs.sendMessage(tabId, {\n    //         type: 'RESTORE_FOCUS_TIMER',\n    //         timerState: activeTimer\n    //       }).catch(err => console.error('Failed to restore timer after content script ready retry:', err));\n    //     }, 500);\n    //   });\n    // }\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"TIMER_EXPIRED\") {\n    // Handle timer expiration from the side panel\n    // endFocusTimer();\n    // Show a drift warning on the current page\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      if (tabs[0] && tabs[0].id) {\n        chrome.tabs.sendMessage(tabs[0].id, {\n          type: \"DRIFT_WARNING\",\n          message: \"Time's up! Return to your primary task now.\"\n        }, (resp) => {\n          if (chrome.runtime.lastError || resp === undefined) {\n            // Nobody listened - fall back to the blocked page\n            chrome.tabs.update(tabs[0].id!, {url: BLOCKED_PAGE_URL});\n          }\n        });\n      }\n    });\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"PARK_LINK\") {\n    const { url, context, title } = request;\n    \n    // Handle the parked link asynchronously\n    (async () => {\n      try {\n        await saveForLater(url, context, title);\n        console.log(`[Parked Links] Saved for later: ${title || url} (${context})`);\n      } catch (error) {\n        console.error(\"Error parking link:\", error);\n      }\n    })();\n    \n    return false; // No response needed\n  }\n  else if (request.type === \"RELEASE_PARKED_LINKS\") {\n    // Handle the release of parked links asynchronously\n    (async () => {\n      try {\n        await releaseParkedLinks();\n        sendResponse({ success: true });\n      } catch (error) {\n        console.error(\"Error releasing parked links:\", error);\n        sendResponse({ success: false, error: String(error) });\n      }\n    })();\n    \n    return true; // Indicates async response\n  }\n  else if (request.type === \"TRAIN_CONTEXT\") {\n    (async () => {\n      const { url, title, actualContext, predictedContext, isFalsePositive } = request;\n      \n      // Get or create context data for this URL\n      const contextData = await getContextData(url);\n      \n      // Update training data\n      if (!contextData.training) {\n        contextData.training = {\n          falsePositives: [],\n          truePositives: []\n        };\n      }\n      \n      if (isFalsePositive) {\n        contextData.training.falsePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      } else {\n        contextData.training.truePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      }\n      \n      // Save updated context data\n      await saveContextData(url, contextData);\n      \n      // Recalculate context weights based on training data\n      await updateContextWeights(url);\n      \n      sendResponse({ success: true });\n    })();\n    return true; // Required for async response\n  }\n  else if (request.type === \"STAY_FOCUSED_ACTION\") {\n    (async () => {\n      const { url, context, title } = request.payload;\n      try {\n        await saveForLater(url, context, title);\n        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (tab?.id) await goBackOrClose(tab.id);\n        sendResponse({ success: true });\n      } catch (e: unknown) {\n        console.error(\"Stay‑focused flow failed:\", e);\n        sendResponse({ \n          success: false, \n          error: e instanceof Error ? e.message : String(e)\n        });\n      }\n    })();\n    return true;\n  }\n  else if (request.type === \"FOCUS_STATUS\") {\n    // Return the current focus state to the popup\n    getFocusState()\n      .then(focusState => sendResponse(focusState))\n      .catch(error => {\n        console.error(\"Error getting focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  \n  return false; // No response needed for other messages\n});\n\n/**\n * Toggle focus mode on/off\n */\nasync function toggleFocusMode(enabled: boolean): Promise<void> {\n  if (enabled) {\n    // Just update badge in the new approach\n    updateBadge();\n  } else {\n    // Ungroup all tabs when focus mode is disabled\n    await ungroupAllTabs();\n    // Clear badge when focus mode is disabled\n    chrome.action.setBadgeText({ text: \"\" });\n  }\n}\n\n/**\n * Handle context update with enhanced data\n */\nasync function handleContextUpdate(\n  tabId: number, \n  context: string, \n  contextData?: any\n): Promise<void> {\n  // Get current settings\n  const { autoGroupEnabled = true } = await getStorage([\n    \"autoGroupEnabled\",\n  ]);\n\n  // If auto-group is off, do nothing\n  if (autoGroupEnabled === false) {\n    return;\n  }\n\n  // Group tab by context\n  await groupTabByContext(tabId, context);\n  \n  // Update badge when context changes\n  updateBadge();\n}\n\n/**\n * Updates the badge with current context switch count\n */\nasync function updateBadge(): Promise<void> {\n  try {\n    // Update to use the new focusState instead of focusModeEnabled\n    const focusState = await getFocusState();\n    \n    // If focus mode is not active, don't show badge\n    if (!focusState.active) {\n      chrome.action.setBadgeText({ text: \"\" });\n      return;\n    }\n    \n    // Check if we're showing focus time or context switches\n    const focusTimeLeftSeconds = await focusEngine.getTimeLeft();\n    \n    if (focusTimeLeftSeconds === -1) {\n      // Unlimited session - show infinity symbol\n      chrome.action.setBadgeText({ text: \"∞\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n    } else if (focusTimeLeftSeconds > 0) {\n      // Display minutes remaining for badge (rounded up)\n      const minutesLeft = Math.ceil(focusTimeLeftSeconds / 60);\n      chrome.action.setBadgeText({ text: minutesLeft.toString() });\n      \n      // Get focus status to determine color\n      const focusStatus = await checkFocusStatus();\n      if (focusStatus.isLostFocus) {\n        chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red for lost focus\n      } else {\n        chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue for focused\n      }\n    } else {\n      // Show context switch count if no timer active\n      const focusStatus = await checkFocusStatus();\n      const switchCount = focusStatus.contextSwitches.length;\n      \n      // Set badge with context switch count\n      chrome.action.setBadgeText({ text: switchCount.toString() });\n      \n      // Change color if focus is lost\n      if (focusStatus.isLostFocus) {\n        chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red for lost focus\n      } else {\n        chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue for focused\n      }\n    }\n  } catch (error) {\n    console.error(\"Error updating badge:\", error);\n  }\n}\n\n/**\n * Send a high-visibility drift warning to the active tab\n */\nasync function sendDriftWarning(focusStatus: any): Promise<void> {\n  try {\n    // Always show warnings during focus sessions regardless of notification settings\n    // This is critical - users need to be alerted when drifting\n    \n    // Check if a focus session is active\n    const isSessionActive = await focusEngine.isActive();\n    if (!isSessionActive) {\n      return; // Only show drift warnings during active focus sessions\n    }\n    \n    console.log(\"[Focus] Sending drift warning to active tab\", focusStatus);\n    \n    // Get the active tab\n    const tabs = await chrome.tabs.query({active: true, currentWindow: true});\n    if (!tabs.length || !tabs[0].id) return;\n\n    const activeTab = tabs[0];\n    const tabId = activeTab.id as number;\n    \n    // Skip chrome:// pages and extension pages\n    if (\n      activeTab.url?.startsWith(\"chrome://\") || \n      activeTab.url?.startsWith(\"chrome-extension://\")\n    ) {\n      return;\n    }\n    \n    // Create a useful message about why focus was lost\n    let message = \"YOU'RE DRIFTING FROM YOUR FOCUS TASK!\";\n    \n    // If we have context switches, mention the last switch\n    if (focusStatus.contextSwitches.length > 0) {\n      const lastSwitch = focusStatus.contextSwitches[focusStatus.contextSwitches.length - 1];\n      message = `FOCUS LOST: Switched from ${lastSwitch.from} to ${lastSwitch.to}`;\n    }\n    \n    // Send the warning with callback to check if handled\n    chrome.tabs.sendMessage(tabId, {\n      type: \"DRIFT_WARNING\",\n      message\n    }, (resp) => {\n      if (chrome.runtime.lastError || resp === undefined) {\n        // Nobody listened - fall back to the blocked page\n        chrome.tabs.update(tabId, {url: BLOCKED_PAGE_URL});\n      }\n    });\n      \n    // Also show a system notification\n    chrome.notifications.create({\n      type: 'basic',\n      iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n      title: 'FOCUS ALERT!',\n      message: message,\n      priority: 2,\n      requireInteraction: true\n    });\n      \n    console.log(\"[Focus] Drift warning sent successfully\");\n  } catch (error) {\n    console.error(\"Error sending drift warning:\", error);\n  }\n}\n\n/**\n * Sets up URL blocking based on focus session\n */\nfunction setupFocusSessionUrlBlocking(): void {\n  // Listen for tab updates (URL changes)\n  chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    // Only check for URL changes\n    if (changeInfo.url && tab.url) {\n      const url = tab.url; // ensure we have a stable copy of the URL string\n      // Handle URL check asynchronously but don't block listener return\n      (async () => {\n        try {\n          // Check if this URL should be blocked\n          const shouldBlock = await checkIfUrlShouldBeBlocked(url);\n          if (shouldBlock) {\n            console.log(`[Focus] Blocking URL: ${url}`);\n            \n            // Use standard BLOCKED_PAGE_URL for consistency with drift warnings\n            try {\n              await chrome.tabs.update(tabId, { url: BLOCKED_PAGE_URL });\n            } catch (error) {\n              // Navigation might already be in progress, just log and continue\n              console.log(\"Tab navigation error (likely already navigating):\", error);\n            }\n          }\n        } catch (error) {\n          console.error(\"Error checking URL:\", error);\n        }\n      })();\n    }\n  });\n}\n\n/**\n * Check if URL should be blocked according to focus state and context\n */\nasync function checkIfUrlShouldBeBlocked(url: string): Promise<boolean> {\n  // Get the focus state\n  const focusState = await getFocusState();\n  \n  // If focus is not active, nothing is blocked\n  if (!focusState.active) {\n    return false;\n  }\n  \n  try {\n    // Classify the URL's context\n    const contextData = await getContextData(url);\n    const context = contextData?.context;\n    \n    if (!context) {\n      // If we can't determine the context, don't block\n      return false;\n    }\n    \n    // Use focusEngine to check if this context is blocked\n    return focusEngine.isBlocked(context);\n  } catch (error) {\n    console.error(\"Error classifying URL:\", error);\n    return false;\n  }\n}\n\n/**\n * Check if a focus session should be ended\n */\nasync function checkFocusSessionStatus(): Promise<void> {\n  const endTime = (await getFocusState()).endTime;\n  if (endTime && Date.now() >= endTime) {\n    const active = await focusEngine.isActive();\n    if (active) {\n      // Focus session time is up\n      await focusEngine.end();\n      console.log(\"[Focus] Session ended automatically due to timeout\");\n      \n      // Show notification to user\n      chrome.notifications.create({\n        type: 'basic',\n        iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n        title: 'Focus Session Complete',\n        message: `Your timed focus session has ended.`,\n      });\n    }\n  }\n}\n\n/**\n * Cleanup in-memory reference on tab removal\n */\nonTabRemoved((removedTabId) => {\n  delete tabContextMap[removedTabId];\n});\n\n// Function to get context data for a URL\nasync function getContextData(url: string): Promise<any> {\n  const result = await chrome.storage.local.get([url]);\n  return result[url] || { contexts: [], training: { falsePositives: [], truePositives: [] } };\n}\n\n// Function to save context data for a URL\nasync function saveContextData(url: string, data: any): Promise<void> {\n  await chrome.storage.local.set({ [url]: data });\n}\n\n// Function to update context weights based on training data\nasync function updateContextWeights(url: string): Promise<void> {\n  const contextData = await getContextData(url);\n  const { training } = contextData;\n  \n  if (!training) return;\n  \n  // Calculate weights based on false positives and true positives\n  const weights: { [key: string]: number } = {};\n  \n  // Decrease weight for contexts that frequently cause false positives\n  training.falsePositives.forEach((fp: any) => {\n    weights[fp.predictedContext] = (weights[fp.predictedContext] || 1) * 0.9;\n  });\n  \n  // Increase weight for contexts that are frequently true positives\n  training.truePositives.forEach((tp: any) => {\n    weights[tp.predictedContext] = (weights[tp.predictedContext] || 1) * 1.1;\n  });\n  \n  // Update context weights\n  contextData.weights = weights;\n  await saveContextData(url, contextData);\n}\n\n// Modify the tabs.onUpdated handler to remove timer-related code\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  // Check if the tab has completed loading\n  if (changeInfo.status === 'complete' && tab.url && !tab.url.startsWith('chrome://')) {\n    // Start a short delay to allow any content scripts to initialize\n    setTimeout(() => {\n      // Remove timer-related code\n      // if (activeTimer && activeTimer.active && activeTimer.endTime > Date.now()) {\n      //   // Target just this specific tab\n      //   chrome.scripting.executeScript({\n      //     target: { tabId },\n      //     func: () => {\n      //       // Force content script to re-check for timer\n      //       chrome.runtime.sendMessage({ type: \"CONTENT_SCRIPT_READY\" });\n      //     }\n      //   }).catch(err => {\n      //     // Ignore errors for restricted pages\n      //   });\n      //   \n      //   // Send the timer state to the newly loaded tab\n      //   chrome.tabs.sendMessage(tabId, {\n      //     type: 'RESTORE_FOCUS_TIMER',\n      //     timerState: activeTimer\n      //   }).catch(err => {\n      //     console.log('Tab not ready yet, will use script injection instead');\n      //     // Use script injection as fallback\n      //     ensureTimerVisibility();\n      //   });\n      // }\n    }, 500);\n  }\n});\n\n// Set default settings on installation/update\nchrome.runtime.onInstalled.addListener(details => {\n  if (details.reason === \"install\") {\n    // First-time install: set defaults\n    chrome.storage.local.set({\n      extensionEnabled: true,\n      autoGroupEnabled: true, // Set auto grouping enabled by default\n      focusState: {\n        active: false,\n        allowedContexts: []\n      },\n      firstRunComplete: false\n    });\n    \n    // Show onboarding page\n    chrome.tabs.create({ url: chrome.runtime.getURL(\"onboarding.html\") });\n  } else if (details.reason === \"update\") {\n    // Handle migration from old storage format to new\n    chrome.storage.local.get([\n      \"autoGroupEnabled\", // Check for this setting\n      \"focusSessionActive\", \n      \"focusSessionEndTime\",\n      \"blockedCategories\",\n      \"focusState\"\n    ], result => {\n      // Always set extension to enabled\n      const update: Record<string, any> = {\n        extensionEnabled: true\n      };\n      \n      // Migration: If we have old format data but no new focusState yet, convert it\n      if (!result.focusState && (result.focusSessionActive || result.blockedCategories)) {\n        console.log(\"Migrating from old focus session format to new focusState format\");\n        \n        // Convert to new FocusState format (invert the block logic to allowedContexts)\n        const knownContexts = [\n          \"Work\", \"Development\", \"Research\", \"Learning\", \n          \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n        ];\n        \n        // Calculate allowed contexts by excluding blocked ones\n        const blockedCategories = result.blockedCategories || [];\n        const allowedContexts = knownContexts.filter(ctx => !blockedCategories.includes(ctx));\n        \n        update.focusState = {\n          active: result.focusSessionActive === true,\n          allowedContexts,\n          endTime: result.focusSessionEndTime || undefined\n        };\n        \n        // Remove old keys after migration\n        chrome.storage.local.remove([\n          \"focusSessionActive\", \n          \"focusSessionEndTime\", \n          \"blockedCategories\"\n        ]);\n      }\n      \n      // Ensure we have explicit boolean values, not undefined  \n      if (result.autoGroupEnabled === undefined) update.autoGroupEnabled = true;\n      \n      // Apply all updates\n      chrome.storage.local.set(update);\n    });\n  }\n});\n\n// Kick off on load\ninitExtension().catch(console.error);","import { getStorage, setStorage } from \"./storageApi\";\nimport { ParkedLink } from \"../types/index\";\n\n/**\n * Save a link for later viewing\n */\nexport async function saveForLater(url: string, context: string, title?: string): Promise<void> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  \n  // Check if the URL is already parked to avoid duplicates\n  const isDuplicate = parkedLinks.some(link => link.url === url);\n  \n  if (!isDuplicate) {\n    const newLink: ParkedLink = {\n      url,\n      title,\n      context,\n      timestamp: Date.now()\n    };\n    \n    await setStorage({\n      parkedLinks: [...parkedLinks, newLink]\n    });\n  }\n}\n\n/**\n * Get all parked links\n */\nexport async function getParkedLinks(): Promise<ParkedLink[]> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  return parkedLinks;\n}\n\n/**\n * Open all parked links in new tabs and clear the list\n */\nexport async function releaseParkedLinks(): Promise<void> {\n  const parkedLinks = await getParkedLinks();\n  \n  if (parkedLinks.length === 0) {\n    return;\n  }\n  \n  // Create a new tab group for the parked links\n  const currentWindow = await chrome.windows.getCurrent();\n  let groupId: number | undefined;\n  \n  try {\n    // Open all the links in new tabs\n    const openedTabIds: number[] = [];\n    \n    for (const link of parkedLinks) {\n      const tab = await chrome.tabs.create({\n        url: link.url,\n        active: false\n      });\n      \n      if (tab.id) {\n        openedTabIds.push(tab.id);\n      }\n    }\n    \n    // Group the tabs if we have any\n    if (openedTabIds.length > 0) {\n      try {\n        groupId = await chrome.tabs.group({\n          tabIds: openedTabIds\n        });\n        \n        if (groupId) {\n          await chrome.tabGroups.update(groupId, {\n            title: \"Parked Links\",\n            color: \"blue\"\n          });\n        }\n      } catch (groupError) {\n        console.error(\"Error creating tab group:\", groupError);\n      }\n    }\n    \n    // Clear the parked links list\n    await setStorage({ parkedLinks: [] });\n    \n    // Show a notification\n    chrome.notifications.create({\n      type: \"basic\",\n      iconUrl: chrome.runtime.getURL(\"icons/icon48.png\"),\n      title: \"Parked Links Opened\",\n      message: `Opened ${parkedLinks.length} links that were saved during your focus session.`\n    });\n  } catch (error) {\n    console.error(\"Error opening parked links:\", error);\n  }\n}\n\n/**\n * More robust function to navigate back or close the current tab\n */\nexport async function goBackOrClose(tabId: number): Promise<void> {\n  try {\n    // Get tab info first to confirm it exists\n    const tab = await chrome.tabs.get(tabId);\n    \n    // First try to determine if we can go back using script injection\n    try {\n      const historyResults = await chrome.scripting.executeScript({\n        target: { tabId },\n        func: () => ({\n          canGoBack: window.history.length > 1,\n          url: window.location.href\n        })\n      });\n      \n      const { canGoBack } = historyResults[0].result;\n      \n      if (canGoBack) {\n        // Navigate back if possible using script injection\n        await chrome.scripting.executeScript({\n          target: { tabId },\n          func: () => window.history.back()\n        });\n        \n        // Success, we're done\n        return;\n      }\n      \n      // Can't go back, use fallback approach\n      await handleNavigationFallback(tabId, tab);\n    } catch (err) {\n      console.error(\"Script execution error:\", err);\n      \n      // Fallback to simpler chrome.tabs.goBack API\n      try {\n        await chrome.tabs.goBack(tabId);\n      } catch (backError) {\n        // If that fails too, use final fallback\n        await handleNavigationFallback(tabId, tab);\n      }\n    }\n  } catch (err) {\n    console.error(\"Tab lookup error:\", err);\n    // Tab might no longer exist, nothing to do\n  }\n}\n\n/**\n * Fallback navigation handler when going back isn't possible\n */\nasync function handleNavigationFallback(tabId: number, tab: chrome.tabs.Tab): Promise<void> {\n  try {\n    // Get all tabs in the window\n    const allTabs = await chrome.tabs.query({ windowId: tab.windowId });\n    \n    if (allTabs.length > 1) {\n      // More than one tab, find one to focus\n      const currentIndex = allTabs.findIndex(t => t.id === tabId);\n      const targetIndex = currentIndex > 0 ? currentIndex - 1 : (currentIndex + 1) % allTabs.length;\n      const targetTab = allTabs[targetIndex];\n      \n      // Focus the other tab first\n      if (targetTab.id) {\n        await chrome.tabs.update(targetTab.id, { active: true });\n        \n        // Then remove the current tab\n        setTimeout(() => {\n          chrome.tabs.remove(tabId).catch(e => {\n            console.error(\"Tab removal failed:\", e);\n          });\n        }, 100);\n      }\n    } else {\n      // Last tab, navigate to blank page instead\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    }\n  } catch (e) {\n    console.error(\"Navigation fallback failed:\", e);\n    // Last resort - try basic navigation\n    try {\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    } catch (finalError) {\n      console.error(\"Final fallback failed:\", finalError);\n    }\n  }\n}\n\n/**\n * Show a toast notification in the current tab\n */\nexport async function showToast(tabId: number, message: string, duration = 3000): Promise<void> {\n  try {\n    await chrome.scripting.executeScript({\n      target: { tabId },\n      func: (msg: string, dur: number) => {\n        const toast = document.createElement(\"div\");\n        toast.style.cssText = `\n          position: fixed;\n          bottom: 20px;\n          right: 20px;\n          background-color: rgba(0, 102, 204, 0.9);\n          color: white;\n          padding: 12px 20px;\n          border-radius: 4px;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n          font-family: Arial, sans-serif;\n          z-index: 2147483647;\n          max-width: 300px;\n          transition: opacity 0.3s ease-in-out;\n        `;\n        toast.textContent = msg;\n        document.body.appendChild(toast);\n        \n        // Fade out and remove\n        setTimeout(() => {\n          toast.style.opacity = \"0\";\n          setTimeout(() => toast.remove(), 300);\n        }, dur - 300);\n      },\n      args: [message, duration]\n    });\n  } catch (error) {\n    console.error(\"Error showing toast:\", error);\n  }\n}\n\n/**\n * Clear all parked links without opening them\n */\nexport async function clearParkedLinks(): Promise<void> {\n  await setStorage({ parkedLinks: [] });\n} ","import { pickColorForContext } from \"../lib/pickColor\";\n\nexport async function groupTabByContext(tabId: number, context: string): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  let existingGroup = groups.find((grp) => grp.title === context);\n\n  if (!existingGroup) {\n    // Create new group if none match\n    const newGroupId = await chrome.tabs.group({ tabIds: [tabId] });\n    existingGroup = await chrome.tabGroups.update(newGroupId, {\n      title: context,\n      color: pickColorForContext(context),\n    });\n  } else {\n    // Add to existing group\n    await chrome.tabs.group({ groupId: existingGroup.id, tabIds: [tabId] });\n  }\n}\n\nexport function onTabRemoved(callback: (tabId: number) => void): void {\n  chrome.tabs.onRemoved.addListener(callback);\n}\n\n/** Ungroup every tab in every window */\nexport async function ungroupAllTabs(): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  for (const g of groups) {\n    const tabs = await chrome.tabs.query({ groupId: g.id });\n    if (tabs.length) {\n      await chrome.tabs.ungroup(tabs.map(t => t.id!));\n    }\n  }\n}","import { getStorage, setStorage } from \"./storageApi\";\nimport { FocusStatus, FocusSettings, ContextSwitch } from \"../types/index\";\n\nconst DEFAULT_FOCUS_SETTINGS: FocusSettings = {\n  enabled: true,\n  notificationsEnabled: true,\n  switchThreshold: 5,\n  timeWindowMinutes: 15\n};\n\n/**\n * Get the current focus settings\n */\nexport async function getFocusSettings(): Promise<FocusSettings> {\n  const { focusSettings } = await getStorage([\"focusSettings\"]);\n  return { ...DEFAULT_FOCUS_SETTINGS, ...focusSettings };\n}\n\n/**\n * Update focus settings\n */\nexport async function updateFocusSettings(settings: Partial<FocusSettings>): Promise<void> {\n  const currentSettings = await getFocusSettings();\n  await setStorage({ \n    focusSettings: { ...currentSettings, ...settings } \n  });\n}\n\n/**\n * Get context switches in a time window\n */\nexport async function getContextSwitches(timeWindowMinutes: number = 15): Promise<ContextSwitch[]> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (!contextHistory || contextHistory.length < 2) {\n    return [];\n  }\n  \n  const switches: ContextSwitch[] = [];\n  const now = Date.now();\n  const timeWindow = timeWindowMinutes * 60 * 1000;\n  \n  // Filter history to time window\n  const relevantHistory = contextHistory.filter(\n    entry => (now - entry.timestamp) < timeWindow\n  );\n  \n  // Find context switches\n  for (let i = 1; i < relevantHistory.length; i++) {\n    if (relevantHistory[i].context !== relevantHistory[i-1].context) {\n      switches.push({\n        from: relevantHistory[i-1].context,\n        to: relevantHistory[i].context,\n        timestamp: relevantHistory[i].timestamp,\n        fromUrl: relevantHistory[i-1].url,\n        toUrl: relevantHistory[i].url\n      });\n    }\n  }\n  \n  return switches;\n}\n\n/**\n * Check if focus is lost based on context switching\n */\nexport async function checkFocusStatus(): Promise<FocusStatus> {\n  const settings = await getFocusSettings();\n  const switches = await getContextSwitches(settings.timeWindowMinutes);\n  \n  let currentContext = \"Unknown\";\n  let currentStreak = 1;\n  \n  // Get most recent context and streak\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (contextHistory && contextHistory.length > 0) {\n    currentContext = contextHistory[contextHistory.length - 1].context;\n    \n    // Count consecutive entries with same context\n    let i = contextHistory.length - 1;\n    while (i > 0 && contextHistory[i].context === currentContext) {\n      currentStreak++;\n      i--;\n    }\n  }\n  \n  // Determine if focus is lost\n  const isLostFocus = switches.length >= settings.switchThreshold;\n  \n  return {\n    isLostFocus,\n    contextSwitches: switches,\n    currentStreak,\n    currentContext\n  };\n}\n\n/**\n * Show focus notification\n */\nexport function showFocusNotification(contextSwitches: ContextSwitch[]): void {\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Alert',\n    message: `You've switched contexts ${contextSwitches.length} times recently. Try to maintain focus.`,\n    buttons: [\n      { title: 'View Details' }\n    ]\n  });\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(545);\n"],"names":["getStorage","keys","Promise","resolve","reject","chrome","storage","local","get","result","runtime","lastError","setStorage","data","set","async","getFocusState","focusState","active","allowedContexts","context","url","confidence","contextHistory","newHistory","push","timestamp","Date","now","length","shift","partialState","currentState","focusWindowId","launchFocusWindow","undefined","windows","error","id","create","type","state","tabs","query","windowId","update","getURL","console","remove","tabId","move","index","blockClearTimer","recentlyBlocked","allowed","durationMin","safeAllowed","Array","isArray","endTime","setFocusState","blockedCategories","filter","ctx","includes","openSidePanel","focusSettings","focusWindowEnabled","action","setBadgeText","text","setBadgeBackgroundColor","color","notifications","iconUrl","title","message","priority","saveWorkspaceName","groups","tabGroups","workspaceGroups","all","map","grp","groupId","tabUrls","t","savedWorkspaces","newWorkspaceEntry","name","updatedWorkspaces","closeSidePanel","closeFocusWindow","ungroupAllTabs","clearTimeout","releaseParkedLinks","log","setTimeout","Math","max","workspace","find","ws","tabIds","createdTab","newGroupId","group","currentWindow","getCurrent","sidePanel","open","panels","getAll","panel","close","path","setOptions","enabled","tabContextMap","BLOCKED_PAGE_URL","updateBadge","focusTimeLeftSeconds","focusEngine","getTimeLeft","minutesLeft","ceil","toString","checkFocusStatus","isLostFocus","focusStatus","switchCount","contextSwitches","getContextData","contexts","training","falsePositives","truePositives","saveContextData","onMessage","addListener","request","sender","sendResponse","tab","secondaryContexts","autoGroupEnabled","groupTabByContext","handleContextUpdate","catch","err","toggleFocusMode","durationMinutes","payload","start","then","success","end","seconds","restoreWorkspace","sendMessage","resp","saveForLater","String","actualContext","predictedContext","isFalsePositive","contextData","weights","forEach","fp","tp","updateContextWeights","goBackOrClose","e","Error","onTabRemoved","removedTabId","onUpdated","changeInfo","status","startsWith","onInstalled","details","reason","extensionEnabled","firstRunComplete","focusSessionActive","knownContexts","focusSessionEndTime","toLocaleTimeString","shouldBlock","isBlocked","checkIfUrlShouldBeBlocked","alarms","periodInMinutes","onAlarm","isActive","checkFocusSessionStatus","activeTab","lastSwitch","from","to","requireInteraction","sendDriftWarning","initExtension","getParkedLinks","parkedLinks","handleNavigationFallback","allTabs","currentIndex","findIndex","targetTab","finalError","some","link","newLink","openedTabIds","groupError","historyResults","scripting","executeScript","target","func","canGoBack","window","history","location","href","back","goBack","backError","duration","msg","dur","toast","document","createElement","style","cssText","textContent","body","appendChild","opacity","args","existingGroup","pickColorForContext","callback","onRemoved","g","ungroup","DEFAULT_FOCUS_SETTINGS","notificationsEnabled","switchThreshold","timeWindowMinutes","getFocusSettings","getContextSwitches","switches","timeWindow","relevantHistory","entry","i","fromUrl","toUrl","settings","currentSettings","currentContext","currentStreak","buttons","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}