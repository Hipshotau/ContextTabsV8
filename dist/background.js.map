{"version":3,"file":"background.js","mappings":"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","sources":["webpack://context-focus/./src/api/storageApi.ts","webpack://context-focus/./src/lib/windows/focusWindow.ts","webpack://context-focus/./src/lib/pickColor.ts","webpack://context-focus/./src/lib/focusEngine.ts","webpack://context-focus/./src/lib/panels/sidePanelManager.ts","webpack://context-focus/./src/api/focusSessionManager.ts","webpack://context-focus/./src/background/index.ts","webpack://context-focus/./src/api/parkedLinksApi.ts","webpack://context-focus/./src/api/tabsApi.ts","webpack://context-focus/./src/api/focusApi.ts","webpack://context-focus/webpack/bootstrap","webpack://context-focus/webpack/startup"],"sourcesContent":["import { FocusSettings, StorageData as TypesStorageData, FocusState } from \"../types/index\";\n\n// Re-export the StorageData interface from types/index.d.ts\nexport type StorageData = TypesStorageData;\n\n/**\n * Get an object containing the requested keys.\n */\nexport function getStorage<T extends keyof StorageData>(\n  keys: T[]\n): Promise<Pick<StorageData, T>> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.get(keys, (result) => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve(result as Pick<StorageData, T>);\n    });\n  });\n}\n\n/**\n * Set or update the given keys in storage.\n */\nexport function setStorage(data: Partial<StorageData>): Promise<void> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.set(data, () => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * Add a context entry to history\n */\nexport async function addContextToHistory(\n  context: string,\n  url: string,\n  confidence: number\n): Promise<void> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  const newHistory = contextHistory || [];\n  \n  // Add new entry\n  newHistory.push({\n    context,\n    url,\n    timestamp: Date.now(),\n    confidence\n  });\n  \n  // Limit history size\n  if (newHistory.length > 100) {\n    newHistory.shift();\n  }\n  \n  await setStorage({ contextHistory: newHistory });\n}\n\n/**\n * Get the current focus state\n */\nexport async function getFocusState(): Promise<FocusState> {\n  const { focusState } = await getStorage([\"focusState\"]);\n  \n  // Default state if none exists\n  const defaultState: FocusState = {\n    active: false,\n    allowedContexts: []\n  };\n  \n  return { ...defaultState, ...focusState };\n}\n\n/**\n * Update the focus state\n */\nexport async function setFocusState(partialState: Partial<FocusState>): Promise<void> {\n  const currentState = await getFocusState();\n  await setStorage({ \n    focusState: { ...currentState, ...partialState }\n  });\n}","let focusWindowId: number | undefined;\n\n/**\n * Create a dedicated window for the focus session\n * This creates a new window that can be populated with productive tabs\n */\nexport async function launchFocusWindow(): Promise<number | undefined> {\n  try {\n    // Check if focus window already exists\n    if (focusWindowId !== undefined) {\n      try {\n        // Try to get window to verify it still exists\n        await chrome.windows.get(focusWindowId);\n        return focusWindowId; // Window already exists\n      } catch (error) {\n        // Window doesn't exist anymore, reset the ID\n        focusWindowId = undefined;\n      }\n    }\n\n    // Create a new window\n    const { id } = await chrome.windows.create({\n      url: \"about:blank\",\n      type: \"normal\",\n      state: \"maximized\"\n    });\n    \n    focusWindowId = id;\n    \n    // Create a welcoming tab\n    if (id) {\n      const tabs = await chrome.tabs.query({ windowId: id });\n      \n      // If there's at least one tab (the default about:blank), update it\n      if (tabs.length > 0 && tabs[0].id) {\n        await chrome.tabs.update(tabs[0].id, { \n          url: chrome.runtime.getURL(\"blocked.html\") + \"?mode=welcome\" \n        });\n      }\n    }\n    \n    return focusWindowId;\n  } catch (error) {\n    console.error(\"Error launching focus window:\", error);\n    return undefined;\n  }\n}\n\n/**\n * Close the dedicated focus window\n */\nexport async function closeFocusWindow(): Promise<void> {\n  if (focusWindowId === undefined) return;\n  \n  try {\n    await chrome.windows.remove(focusWindowId);\n    focusWindowId = undefined;\n  } catch (error) {\n    console.error(\"Error closing focus window:\", error);\n    // Reset the ID even if there was an error\n    focusWindowId = undefined;\n  }\n}\n\n/**\n * Check if the focus window is active\n */\nexport function getFocusWindowId(): number | undefined {\n  return focusWindowId;\n}\n\n/**\n * Move a tab to the focus window\n */\nexport async function moveTabToFocusWindow(tabId: number): Promise<boolean> {\n  if (focusWindowId === undefined) {\n    const windowId = await launchFocusWindow();\n    if (windowId === undefined) return false;\n  }\n  \n  try {\n    await chrome.tabs.move(tabId, { windowId: focusWindowId!, index: -1 });\n    return true;\n  } catch (error) {\n    console.error(\"Error moving tab to focus window:\", error);\n    return false;\n  }\n} ","export function pickColorForContext(context: string): chrome.tabGroups.ColorEnum {\n  switch (context) {\n    case \"Work\":\n      return \"yellow\";\n    case \"Learning\":\n      return \"blue\";\n    case \"Entertainment\":\n      return \"green\";\n    case \"News\":\n      return \"red\";\n    case \"Shopping\":\n      return \"purple\";\n    case \"Social\":\n      return \"cyan\";\n    case \"Research\":\n      return \"pink\";\n    case \"Development\":\n      return \"orange\";\n    default:\n      return \"grey\";  // Chrome uses \"grey\" (British spelling) not \"gray\"\n  }\n}","/**\n * Focus Engine - Core logic for the Focus feature\n * \n * This module implements the state machine for focus mode, following the principle\n * of \"block by exclusion\" - where user picks ALLOWED contexts and everything else is blocked.\n */\n\nimport { getFocusState, setFocusState } from \"../api/storageApi\";\nimport { FocusState } from \"../types/index\";\n\n// State for tracking if a navigation was blocked recently (for badge alert)\nlet recentlyBlocked = false;\nlet blockClearTimer: NodeJS.Timeout | undefined;\nlet endTimeCheckInterval: NodeJS.Timeout | undefined;\n\n/**\n * Start a focus session\n * \n * @param allowed - Array of context categories that are allowed during focus\n * @param durationMin - Optional duration in minutes after which focus will automatically end\n */\nexport async function start(allowed: string[], durationMin?: number): Promise<void> {\n  // Safety check for allowed contexts\n  const safeAllowed = Array.isArray(allowed) ? allowed : [];\n  \n  // Calculate end time if duration is provided\n  const endTime = durationMin ? Date.now() + durationMin * 60 * 1000 : undefined;\n  \n  // Save focus state\n  await setFocusState({\n    active: true,\n    allowedContexts: safeAllowed,\n    endTime\n  });\n  \n  // Set badge to show focus is active\n  chrome.action.setBadgeText({ text: \"•\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n  \n  // Setup interval to check for timer expiration\n  if (endTime) {\n    if (endTimeCheckInterval) {\n      clearInterval(endTimeCheckInterval);\n    }\n    \n    endTimeCheckInterval = setInterval(async () => {\n      const focusState = await getFocusState();\n      \n      if (focusState.active && focusState.endTime && focusState.endTime <= Date.now()) {\n        // Timer expired, end focus session\n        console.log(\"Focus timer expired automatically\");\n        end();\n        \n        // Show a notification\n        chrome.notifications.create({\n          type: 'basic',\n          iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n          title: 'Focus Session Ended',\n          message: 'Your focus session has ended. Great job!',\n          priority: 2\n        });\n      }\n    }, 15000); // Check every 15 seconds\n  }\n}\n\n/**\n * End a focus session\n */\nexport async function end(): Promise<void> {\n  // Clear focus state\n  await setFocusState({\n    active: false,\n    endTime: undefined\n  });\n  \n  // Clear badge\n  chrome.action.setBadgeText({ text: \"\" });\n  \n  // Clear timer interval\n  if (endTimeCheckInterval) {\n    clearInterval(endTimeCheckInterval);\n    endTimeCheckInterval = undefined;\n  }\n  \n  // Reset block indicator\n  recentlyBlocked = false;\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n    blockClearTimer = undefined;\n  }\n}\n\n/**\n * Check if a context should be blocked\n * \n * @param context - The context category to check\n * @returns true if the context should be blocked, false otherwise\n */\nexport async function isBlocked(context: string): Promise<boolean> {\n  const focusState = await getFocusState();\n  \n  // If focus is not active, nothing is blocked\n  if (!focusState.active) {\n    return false;\n  }\n  \n  // Safety check: ensure allowedContexts is an array before using includes\n  if (!Array.isArray(focusState.allowedContexts)) {\n    console.error(\"[FocusEngine] allowedContexts is not an array:\", focusState.allowedContexts);\n    return false; // Fail open rather than blocking everything\n  }\n  \n  // Add logging to help debug\n  console.log(\"[FocusEngine] allowed:\", focusState.allowedContexts, \"context:\", context);\n  \n  // If context is in allowed list, it's not blocked\n  if (focusState.allowedContexts.includes(context)) {\n    return false;\n  }\n  \n  // Context is not in allowed list, so it's blocked\n  // Update the \"recently blocked\" state for badge\n  recentlyBlocked = true;\n  \n  // Show red \"!\" badge\n  chrome.action.setBadgeText({ text: \"!\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red\n  \n  // Clear the blocked indicator after 30 seconds\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n  }\n  \n  blockClearTimer = setTimeout(() => {\n    if (recentlyBlocked) {\n      recentlyBlocked = false;\n      // Restore the normal focus badge\n      chrome.action.setBadgeText({ text: \"•\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n    }\n  }, 30000);\n  \n  return true;\n}\n\n/**\n * Check if a focus session is currently active\n * \n * @returns true if a focus session is active, false otherwise\n */\nexport async function isActive(): Promise<boolean> {\n  const focusState = await getFocusState();\n  return focusState.active;\n}\n\n/**\n * Get the time left in the current focus session in minutes\n * \n * @returns Minutes left in the focus session, or 0 if no session or no timer\n */\nexport async function getTimeLeft(): Promise<number> {\n  const focusState = await getFocusState();\n  \n  if (!focusState.active || !focusState.endTime) {\n    return 0;\n  }\n  \n  const timeLeftMs = Math.max(0, focusState.endTime - Date.now());\n  return Math.floor(timeLeftMs / 60000); // Convert to minutes\n} ","/**\n * Open the side panel in the current window\n */\nexport async function openSidePanel(): Promise<void> {\n  try {\n    const currentWindow = await chrome.windows.getCurrent();\n    await chrome.sidePanel.open({ windowId: currentWindow.id });\n    console.log(\"Side panel opened successfully\");\n  } catch (error) {\n    console.error(\"Error opening side panel:\", error);\n  }\n}\n\n/**\n * Close the side panel in all windows\n */\nexport async function closeSidePanel(): Promise<void> {\n  try {\n    const panels = await chrome.sidePanel.getAll();\n    await Promise.all(panels.map((panel: chrome.sidePanel.PanelInfo) => \n      chrome.sidePanel.close({ windowId: panel.windowId })\n    ));\n    console.log(\"Side panels closed successfully\");\n  } catch (error) {\n    console.error(\"Error closing side panels:\", error);\n  }\n}\n\n/**\n * Set the side panel properties\n */\nexport async function setSidePanelProperties(path: string, title: string): Promise<void> {\n  try {\n    await chrome.sidePanel.setOptions({\n      path,\n      enabled: true\n    });\n    console.log(\"Side panel properties updated\");\n  } catch (error) {\n    console.error(\"Error setting side panel properties:\", error);\n  }\n} ","import { getStorage, setStorage, getFocusState, setFocusState } from \"./storageApi\";\nimport { StorageData } from \"../types/index\";\nimport { groupTabByContext, ungroupAllTabs } from \"./tabsApi\";\nimport { classifyPageContext } from \"../lib/contextEngine\";\nimport { extractDomain } from \"../lib/contextEngine/urlAnalyzer\";\nimport { launchFocusWindow, closeFocusWindow } from \"../lib/windows/focusWindow\";\nimport { openSidePanel, closeSidePanel } from \"../lib/panels/sidePanelManager\";\nimport { releaseParkedLinks } from \"./parkedLinksApi\";\n\n// Set up periodic badge updates\nlet badgeUpdateInterval: number | undefined;\n\n// Flag to track if alarm listener is already set up\nlet alarmListenerRegistered = false;\n\n/**\n * Start a Focus Session with a specified duration (minutes) and a set of blocked categories.\n * Activates all visual, auditory, and spatial cues for maximum ADHD-friendly feedback.\n */\nexport async function startFocusSession(durationMinutes: number, blockedCategories: string[]): Promise<void> {\n  const now = Date.now();\n  const endTime = now + durationMinutes * 60_000;\n\n  // Convert blockedCategories to allowedContexts by excluding them from all known contexts\n  const knownContexts = [\n    \"Work\", \"Development\", \"Research\", \"Learning\", \n    \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n  ];\n  const allowedContexts = knownContexts.filter(ctx => !blockedCategories.includes(ctx));\n\n  // Mark focus session as active using the new focusState object\n  await setFocusState({\n    active: true,\n    allowedContexts,\n    endTime\n  });\n\n  // Also store blockedCategories for backward compatibility with UI\n  await setStorage({ blockedCategories });\n\n  // Open the side panel for persistent timer display\n  await openSidePanel();\n\n  // Update the badge and icon to indicate focus mode\n  updateBadge(durationMinutes, false);\n  \n  // Set up alarms for badge updates instead of setInterval\n  chrome.alarms.create('badgeUpdate', { periodInMinutes: 0.2 });\n  \n  // Set up the alarm listener only once\n  if (!alarmListenerRegistered) {\n    chrome.alarms.onAlarm.addListener(async (alarm) => {\n      if (alarm.name !== 'badgeUpdate') return;\n      const timeLeft = await getFocusSessionTimeLeft();\n      const drifting = await checkIfDrifting();\n      updateBadge(timeLeft / 60, drifting); // Convert seconds to minutes\n    });\n    \n    alarmListenerRegistered = true;\n  }\n  \n  // Optionally launch a dedicated focus window\n  const storage = await getStorage([\"focusSettings\"]);\n  const focusWindowEnabled = storage.focusSettings?.focusWindowEnabled || false;\n  if (focusWindowEnabled) {\n    await launchFocusWindow();\n  }\n\n  // Show notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Started',\n    message: `Focus session started for ${durationMinutes} minutes. Stay focused!`,\n  });\n}\n\n/**\n * End the current Focus Session.\n * Optionally save the workspace (tab groups) if user requests.\n */\nexport async function endFocusSession(saveWorkspace: boolean, workspaceName: string = \"\"): Promise<void> {\n  // If user wants to save workspace, store it\n  if (saveWorkspace && workspaceName) {\n    await saveCurrentWorkspace(workspaceName);\n  }\n\n  // Clear focus state using the new API\n  await setFocusState({\n    active: false,\n    endTime: undefined\n  });\n  \n  // Close the side panel\n  await closeSidePanel();\n  \n  // Ungroup all tabs\n  await ungroupAllTabs();\n  \n  // Clear badge and restore icon\n  chrome.action.setBadgeText({ text: \"\" });\n  chrome.action.setIcon({ path: chrome.runtime.getURL('icons/icon48.png') });\n  \n  // Clear the alarms\n  chrome.alarms.clear('badgeUpdate');\n  \n  // Close focus window if it exists\n  await closeFocusWindow();\n  \n  // Show end notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Ended',\n    message: `Great job! Your focus session has ended.`,\n  });\n  \n  // Release any links that were parked during the session\n  await releaseParkedLinks();\n}\n\n/**\n * Updates the badge text and color based on session state\n */\nfunction updateBadge(timeLeftMin: number, drifting: boolean) {\n  chrome.action.setBadgeBackgroundColor({\n    color: drifting ? \"#d32f2f\" : \"#1565c0\"  // red if drifting, blue otherwise\n  });\n  \n  chrome.action.setBadgeText({\n    text: timeLeftMin > 0 ? Math.ceil(timeLeftMin).toString() : \"\"\n  });\n  \n  chrome.action.setIcon({\n    path: drifting ? \n      chrome.runtime.getURL('icons/icon48.png') : // Would be focus_drift.png if it existed\n      chrome.runtime.getURL('icons/icon48.png')   // Would be focus_on.png if it existed\n  });\n}\n\n/**\n * Check if the user is currently drifting from focus\n */\nasync function checkIfDrifting(): Promise<boolean> {\n  const { focusSettings } = await getStorage([\"focusSettings\"]);\n  if (!focusSettings) return false;\n  \n  // For now, we'll just use a simple check based on the existing focus API\n  const response = await chrome.runtime.sendMessage({ type: \"CHECK_FOCUS_STATUS\" });\n  return response?.isLostFocus || false;\n}\n\n/**\n * Check if a focus session is currently active\n */\nexport async function isFocusSessionActive(): Promise<boolean> {\n  const focusState = await getFocusState();\n  return focusState.active;\n}\n\n/**\n * Returns how many seconds remain in the current focus session (if any)\n */\nexport async function getFocusSessionTimeLeft(): Promise<number> {\n  const focusState = await getFocusState();\n  if (!focusState.active || !focusState.endTime) return 0;\n\n  const now = Date.now();\n  const diff = focusState.endTime - now;\n  return diff > 0 ? diff / 1000 : 0;   // Return seconds, not minutes\n}\n\n/**\n * Determine if this URL is blocked under the current Focus Session settings.\n */\nexport async function isUrlBlocked(url: string, detectedCategory: string): Promise<boolean> {\n  const focusState = await getFocusState();\n\n  // If session not active, not blocked\n  if (!focusState.active) {\n    return false;\n  }\n\n  // If the context is not in allowed contexts, block it\n  if (detectedCategory && !focusState.allowedContexts.includes(detectedCategory)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Save current window's tab groups (workspace).\n * This can be called at the end of a Focus Session or on demand.\n */\nexport async function saveCurrentWorkspace(name: string): Promise<void> {\n  // Get all tab groups\n  const groups = await chrome.tabGroups.query({});\n  // For each group, gather tab URLs\n  const workspaceGroups = await Promise.all(\n    groups.map(async (grp) => {\n      const tabs = await chrome.tabs.query({ groupId: grp.id });\n      return {\n        groupId: grp.id,\n        title: grp.title || \"\",\n        color: grp.color,\n        tabUrls: tabs.map(t => t.url || \"\")\n      };\n    })\n  );\n\n  // Store in savedWorkspaces\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  const newWorkspaceEntry = {\n    name,\n    tabGroups: workspaceGroups,\n    timestamp: Date.now()\n  };\n\n  const updatedWorkspaces = Array.isArray(savedWorkspaces) \n    ? [...savedWorkspaces, newWorkspaceEntry]\n    : [newWorkspaceEntry];\n\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n}\n\n/**\n * Restore a saved workspace by name. \n * Re-open tabs and re-create groups (approximation).\n */\nexport async function restoreWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const workspace = savedWorkspaces.find(ws => ws.name === name);\n  if (!workspace) return;\n\n  // For each group, re-create tabs\n  for (const grp of workspace.tabGroups) {\n    // Open each tab\n    const tabIds = [];\n    for (const url of grp.tabUrls) {\n      const createdTab = await chrome.tabs.create({ url, active: false });\n      tabIds.push(createdTab.id as number);\n    }\n    // Create or update tab group\n    if (tabIds.length > 0) {\n      const newGroupId = await chrome.tabs.group({ tabIds });\n      await chrome.tabGroups.update(newGroupId, {\n        title: grp.title || \"\",\n        color: grp.color\n      });\n    }\n  }\n}\n\n/**\n * Clean up old workspace entries if needed, or remove a workspace by name, etc.\n */\nexport async function removeWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const updatedWorkspaces = savedWorkspaces.filter(ws => ws.name !== name);\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n} ","import { groupTabByContext, onTabRemoved, ungroupAllTabs } from \"../api/tabsApi\";\nimport { getStorage, setStorage, getFocusState, setFocusState } from \"../api/storageApi\";\nimport { checkFocusStatus, showFocusNotification } from \"../api/focusApi\";\nimport { restoreWorkspace } from \"../api/focusSessionManager\";\nimport { classifyPageContext } from \"../lib/contextEngine\";\nimport { extractDomain } from \"../lib/contextEngine/urlAnalyzer\";\nimport { saveForLater, releaseParkedLinks, goBackOrClose } from \"../api/parkedLinksApi\";\nimport * as focusEngine from \"../lib/focusEngine\";\n\nconst tabContextMap: Record<number, string> = {};\nconst BLOCKED_PAGE_URL = chrome.runtime.getURL(\"blocked.html\");\n\n/**\n * Initialize the extension with proper default settings\n */\nasync function initExtension(): Promise<void> {\n  // Always enable the extension\n  await setStorage({ extensionEnabled: true });\n  \n  console.log(\"[Background] Extension enabled.\");\n  \n  // Check for active sessions - now using the new focusState\n  const focusState = await getFocusState();\n  if (focusState.active) {\n    console.log(\"[Background] Focus session was active at shutdown, verifying...\");\n    // Verify session is still valid (not expired)\n    if (!focusState.endTime || focusState.endTime <= Date.now()) {\n      console.log(\"[Background] Focus session expired during shutdown, cleaning up\");\n      await setFocusState({ active: false, endTime: undefined });\n    } else {\n      console.log(`[Background] Focus session continues until ${new Date(focusState.endTime).toLocaleTimeString()}`);\n    }\n  }\n  \n  // Setup URL blocking for Focus Session - always setup the handler\n  setupFocusSessionUrlBlocking();\n  \n  // Set up periodic checks\n  setupPeriodicChecks();\n}\n\n/**\n * Set up all periodic checks needed for the extension\n */\nfunction setupPeriodicChecks() {\n  // Periodic check for session end\n  setInterval(checkFocusSessionStatus, 30000); // check every 30s\n  \n  // More frequent check for focus loss during active sessions\n  setInterval(async () => {\n    try {\n      const isSessionActive = await focusEngine.isActive();\n      if (isSessionActive) {\n        const focusStatus = await checkFocusStatus();\n        if (focusStatus.isLostFocus) {\n          // Immediately send a drift warning if focus is lost\n          await sendDriftWarning(focusStatus);\n        }\n        // Update badge regardless\n        updateBadge();\n      }\n    } catch (err) {\n      console.error(\"Error in focus check interval:\", err);\n    }\n  }, 10000); // Check every 10 seconds during active sessions\n}\n\n/**\n * Handle messages from content scripts and the UI\n */\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.type === \"CONTEXT_UPDATE\" || request.type === \"CONTEXT_DETECTED\") {\n    const context = request.context as string;\n    const tabId = sender.tab?.id;\n    \n    if (tabId != null) {\n      // Check if context has changed\n      const previousContext = tabContextMap[tabId];\n      if (previousContext !== context) {\n        // Notify focus mode about context change\n        // handleContextChange(context);\n      }\n      \n      tabContextMap[tabId] = context;\n      \n      // Store additional context data if available\n      const contextData = {\n        context,\n        confidence: request.confidence,\n        secondaryContexts: request.secondaryContexts,\n        url: request.url\n      };\n      \n      // Save context data to storage for URL blocking functionality\n      chrome.storage.local.set({\n        [request.url]: { context: request.context, confidence: request.confidence }\n      });\n      \n      // Handle the context update\n      handleContextUpdate(tabId, context, contextData).catch((err) => console.error(err));\n    }\n    \n    return false; // No response needed\n  } \n  else if (request.type === \"FOCUS_TOGGLE\") {\n    toggleFocusMode(request.enabled).catch((err) => console.error(err));\n    return false; // No response needed\n  }\n  else if (request.type === \"START_FOCUS_SESSION\") {\n    const { durationMinutes, blockedCategories } = request.payload || {};\n    \n    const KNOWN_CONTEXTS = [\n      \"Work\", \"Development\", \"Research\", \"Learning\",\n      \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n    ];\n    const allowedContexts = KNOWN_CONTEXTS.filter(\n      ctx => !blockedCategories?.includes(ctx)\n    );\n    \n    focusEngine.start(allowedContexts, durationMinutes)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Indicates async response\n  }\n  else if (request.type === \"END_FOCUS_SESSION\") {\n    focusEngine.end()\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(\"Error ending focus session:\", err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"GET_FOCUS_TIME_LEFT\") {\n    getFocusState()\n      .then(focusState => {\n        const seconds = focusState.endTime\n          ? Math.max(0, (focusState.endTime - Date.now()) / 1000)\n          : 0;\n        sendResponse({ seconds });\n      })\n      .catch(error => {\n        console.error(\"Error getting focus time left:\", error);\n        sendResponse({ seconds: 0 });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"OVERRIDE_BLOCK\") {\n    // Allow explicit override\n    // Just respond with success, this would unblock the tab \n    // if we had a temporary block list\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"RESTORE_WORKSPACE\") {\n    const { name } = request.payload || {};\n    restoreWorkspace(name)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Indicates async response\n  }\n  else if (request.type === \"CHECK_FOCUS_STATUS\") {\n    checkFocusStatus()\n      .then(result => sendResponse(result))\n      .catch(error => {\n        console.error(\"Error checking focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"CONTENT_SCRIPT_READY\") {\n    // Content script is ready to receive messages\n    const tabId = sender.tab?.id;\n    // if (tabId && activeTimer && activeTimer.active && activeTimer.endTime > Date.now()) {\n    //   console.log(`Tab ${tabId} is ready, sending active timer`);\n    //   // Send the timer right away\n    //   chrome.tabs.sendMessage(tabId, {\n    //     type: \"RESTORE_FOCUS_TIMER\",\n    //     timerState: activeTimer\n    //   }).catch(err => {\n    //     console.log('Tab not fully ready, will retry');\n    //     // Try again after a short delay\n    //     setTimeout(() => {\n    //       chrome.tabs.sendMessage(tabId, {\n    //         type: 'RESTORE_FOCUS_TIMER',\n    //         timerState: activeTimer\n    //       }).catch(err => console.error('Failed to restore timer after content script ready retry:', err));\n    //     }, 500);\n    //   });\n    // }\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"TIMER_EXPIRED\") {\n    // Handle timer expiration from the side panel\n    // endFocusTimer();\n    // Show a drift warning on the current page\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      if (tabs[0] && tabs[0].id) {\n        chrome.tabs.sendMessage(tabs[0].id, {\n          type: \"DRIFT_WARNING\",\n          message: \"Time's up! Return to your primary task now.\"\n        }, (resp) => {\n          if (chrome.runtime.lastError || resp === undefined) {\n            // Nobody listened - fall back to the blocked page\n            chrome.tabs.update(tabs[0].id!, {url: BLOCKED_PAGE_URL});\n          }\n        });\n      }\n    });\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"PARK_LINK\") {\n    const { url, context, title } = request;\n    \n    // Handle the parked link asynchronously\n    (async () => {\n      try {\n        await saveForLater(url, context, title);\n        console.log(`[Parked Links] Saved for later: ${title || url} (${context})`);\n      } catch (error) {\n        console.error(\"Error parking link:\", error);\n      }\n    })();\n    \n    return false; // No response needed\n  }\n  else if (request.type === \"RELEASE_PARKED_LINKS\") {\n    // Handle the release of parked links asynchronously\n    (async () => {\n      try {\n        await releaseParkedLinks();\n        sendResponse({ success: true });\n      } catch (error) {\n        console.error(\"Error releasing parked links:\", error);\n        sendResponse({ success: false, error: String(error) });\n      }\n    })();\n    \n    return true; // Indicates async response\n  }\n  else if (request.type === \"TRAIN_CONTEXT\") {\n    (async () => {\n      const { url, title, actualContext, predictedContext, isFalsePositive } = request;\n      \n      // Get or create context data for this URL\n      const contextData = await getContextData(url);\n      \n      // Update training data\n      if (!contextData.training) {\n        contextData.training = {\n          falsePositives: [],\n          truePositives: []\n        };\n      }\n      \n      if (isFalsePositive) {\n        contextData.training.falsePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      } else {\n        contextData.training.truePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      }\n      \n      // Save updated context data\n      await saveContextData(url, contextData);\n      \n      // Recalculate context weights based on training data\n      await updateContextWeights(url);\n      \n      sendResponse({ success: true });\n    })();\n    return true; // Required for async response\n  }\n  else if (request.type === \"STAY_FOCUSED_ACTION\") {\n    (async () => {\n      const { url, context, title } = request.payload;\n      try {\n        await saveForLater(url, context, title);\n        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (tab?.id) await goBackOrClose(tab.id);\n        sendResponse({ success: true });\n      } catch (e: unknown) {\n        console.error(\"Stay‑focused flow failed:\", e);\n        sendResponse({ \n          success: false, \n          error: e instanceof Error ? e.message : String(e)\n        });\n      }\n    })();\n    return true;\n  }\n  else if (request.type === \"FOCUS_STATUS\") {\n    // Return the current focus state to the popup\n    getFocusState()\n      .then(focusState => sendResponse(focusState))\n      .catch(error => {\n        console.error(\"Error getting focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  \n  return false; // No response needed for other messages\n});\n\n/**\n * Toggle focus mode on/off\n */\nasync function toggleFocusMode(enabled: boolean): Promise<void> {\n  if (enabled) {\n    // Just update badge in the new approach\n    updateBadge();\n  } else {\n    // Ungroup all tabs when focus mode is disabled\n    await ungroupAllTabs();\n    // Clear badge when focus mode is disabled\n    chrome.action.setBadgeText({ text: \"\" });\n  }\n}\n\n/**\n * Handle context update with enhanced data\n */\nasync function handleContextUpdate(\n  tabId: number, \n  context: string, \n  contextData?: any\n): Promise<void> {\n  // Get current settings\n  const { autoGroupEnabled = true } = await getStorage([\n    \"autoGroupEnabled\",\n  ]);\n\n  // If auto-group is off, do nothing\n  if (autoGroupEnabled === false) {\n    return;\n  }\n\n  // Group tab by context\n  await groupTabByContext(tabId, context);\n  \n  // Update badge when context changes\n  updateBadge();\n}\n\n/**\n * Updates the badge with current context switch count\n */\nasync function updateBadge(): Promise<void> {\n  try {\n    // Update to use the new focusState instead of focusModeEnabled\n    const focusState = await getFocusState();\n    \n    // If focus mode is not active, don't show badge\n    if (!focusState.active) {\n      chrome.action.setBadgeText({ text: \"\" });\n      return;\n    }\n    \n    // Check if we're showing focus time or context switches\n    const focusTimeLeft = await focusEngine.getTimeLeft();\n    \n    if (focusTimeLeft > 0) {\n      // Convert seconds to minutes for badge\n      const minutesLeft = Math.ceil(focusTimeLeft / 60);\n      chrome.action.setBadgeText({ text: minutesLeft.toString() });\n      \n      // Get focus status to determine color\n      const focusStatus = await checkFocusStatus();\n      if (focusStatus.isLostFocus) {\n        chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red for lost focus\n      } else {\n        chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue for focused\n      }\n    } else {\n      // Show context switch count if no timer active\n      const focusStatus = await checkFocusStatus();\n      const switchCount = focusStatus.contextSwitches.length;\n      \n      // Set badge with context switch count\n      chrome.action.setBadgeText({ text: switchCount.toString() });\n      \n      // Change color if focus is lost\n      if (focusStatus.isLostFocus) {\n        chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red for lost focus\n      } else {\n        chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue for focused\n      }\n    }\n  } catch (error) {\n    console.error(\"Error updating badge:\", error);\n  }\n}\n\n/**\n * Send a high-visibility drift warning to the active tab\n */\nasync function sendDriftWarning(focusStatus: any): Promise<void> {\n  try {\n    // Always show warnings during focus sessions regardless of notification settings\n    // This is critical - users need to be alerted when drifting\n    \n    // Check if a focus session is active\n    const isSessionActive = await focusEngine.isActive();\n    if (!isSessionActive) {\n      return; // Only show drift warnings during active focus sessions\n    }\n    \n    console.log(\"[Focus] Sending drift warning to active tab\", focusStatus);\n    \n    // Get the active tab\n    const tabs = await chrome.tabs.query({active: true, currentWindow: true});\n    if (!tabs.length || !tabs[0].id) return;\n\n    const activeTab = tabs[0];\n    const tabId = activeTab.id as number;\n    \n    // Skip chrome:// pages and extension pages\n    if (\n      activeTab.url?.startsWith(\"chrome://\") || \n      activeTab.url?.startsWith(\"chrome-extension://\")\n    ) {\n      return;\n    }\n    \n    // Create a useful message about why focus was lost\n    let message = \"YOU'RE DRIFTING FROM YOUR FOCUS TASK!\";\n    \n    // If we have context switches, mention the last switch\n    if (focusStatus.contextSwitches.length > 0) {\n      const lastSwitch = focusStatus.contextSwitches[focusStatus.contextSwitches.length - 1];\n      message = `FOCUS LOST: Switched from ${lastSwitch.from} to ${lastSwitch.to}`;\n    }\n    \n    // Send the warning with callback to check if handled\n    chrome.tabs.sendMessage(tabId, {\n      type: \"DRIFT_WARNING\",\n      message\n    }, (resp) => {\n      if (chrome.runtime.lastError || resp === undefined) {\n        // Nobody listened - fall back to the blocked page\n        chrome.tabs.update(tabId, {url: BLOCKED_PAGE_URL});\n      }\n    });\n      \n    // Also show a system notification\n    chrome.notifications.create({\n      type: 'basic',\n      iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n      title: 'FOCUS ALERT!',\n      message: message,\n      priority: 2,\n      requireInteraction: true\n    });\n      \n    console.log(\"[Focus] Drift warning sent successfully\");\n  } catch (error) {\n    console.error(\"Error sending drift warning:\", error);\n  }\n}\n\n/**\n * Sets up URL blocking based on focus session\n */\nfunction setupFocusSessionUrlBlocking(): void {\n  // Listen for tab updates (URL changes)\n  chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\n    // Only check for URL changes\n    if (changeInfo.url && tab.url) {\n      try {\n        // Check if this URL should be blocked\n        const shouldBlock = await checkIfUrlShouldBeBlocked(tab.url);\n        if (shouldBlock) {\n          console.log(`[Focus] Blocking URL: ${tab.url}`);\n          \n          // Use standard BLOCKED_PAGE_URL for consistency with drift warnings\n          chrome.tabs.update(tabId, { url: BLOCKED_PAGE_URL });\n        }\n      } catch (error) {\n        console.error(\"Error checking URL:\", error);\n      }\n    }\n  });\n}\n\n/**\n * Check if URL should be blocked according to focus state and context\n */\nasync function checkIfUrlShouldBeBlocked(url: string): Promise<boolean> {\n  // Get the focus state\n  const focusState = await getFocusState();\n  \n  // If focus is not active, nothing is blocked\n  if (!focusState.active) {\n    return false;\n  }\n  \n  try {\n    // Classify the URL's context\n    const contextData = await getContextData(url);\n    const context = contextData?.context;\n    \n    if (!context) {\n      // If we can't determine the context, don't block\n      return false;\n    }\n    \n    // Use focusEngine to check if this context is blocked\n    return focusEngine.isBlocked(context);\n  } catch (error) {\n    console.error(\"Error classifying URL:\", error);\n    return false;\n  }\n}\n\n/**\n * Periodically check if a focus session should be ended\n */\nasync function checkFocusSessionStatus(): Promise<void> {\n  const timeLeft = await focusEngine.getTimeLeft();\n  if (timeLeft <= 0) {\n    const active = await focusEngine.isActive();\n    if (active) {\n      // Focus session time is up\n      await focusEngine.end();\n      console.log(\"[Focus] Session ended automatically due to timeout\");\n      \n      // Show notification to user\n      chrome.notifications.create({\n        type: 'basic',\n        iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n        title: 'Focus Session Complete',\n        message: `Your timed focus session has ended.`,\n      });\n    }\n  }\n}\n\n/**\n * Cleanup in-memory reference on tab removal\n */\nonTabRemoved((removedTabId) => {\n  delete tabContextMap[removedTabId];\n});\n\n// Function to get context data for a URL\nasync function getContextData(url: string): Promise<any> {\n  const result = await chrome.storage.local.get([url]);\n  return result[url] || { contexts: [], training: { falsePositives: [], truePositives: [] } };\n}\n\n// Function to save context data for a URL\nasync function saveContextData(url: string, data: any): Promise<void> {\n  await chrome.storage.local.set({ [url]: data });\n}\n\n// Function to update context weights based on training data\nasync function updateContextWeights(url: string): Promise<void> {\n  const contextData = await getContextData(url);\n  const { training } = contextData;\n  \n  if (!training) return;\n  \n  // Calculate weights based on false positives and true positives\n  const weights: { [key: string]: number } = {};\n  \n  // Decrease weight for contexts that frequently cause false positives\n  training.falsePositives.forEach((fp: any) => {\n    weights[fp.predictedContext] = (weights[fp.predictedContext] || 1) * 0.9;\n  });\n  \n  // Increase weight for contexts that are frequently true positives\n  training.truePositives.forEach((tp: any) => {\n    weights[tp.predictedContext] = (weights[tp.predictedContext] || 1) * 1.1;\n  });\n  \n  // Update context weights\n  contextData.weights = weights;\n  await saveContextData(url, contextData);\n}\n\n// Modify the tabs.onUpdated handler to remove timer-related code\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  // Check if the tab has completed loading\n  if (changeInfo.status === 'complete' && tab.url && !tab.url.startsWith('chrome://')) {\n    // Start a short delay to allow any content scripts to initialize\n    setTimeout(() => {\n      // Remove timer-related code\n      // if (activeTimer && activeTimer.active && activeTimer.endTime > Date.now()) {\n      //   // Target just this specific tab\n      //   chrome.scripting.executeScript({\n      //     target: { tabId },\n      //     func: () => {\n      //       // Force content script to re-check for timer\n      //       chrome.runtime.sendMessage({ type: \"CONTENT_SCRIPT_READY\" });\n      //     }\n      //   }).catch(err => {\n      //     // Ignore errors for restricted pages\n      //   });\n      //   \n      //   // Send the timer state to the newly loaded tab\n      //   chrome.tabs.sendMessage(tabId, {\n      //     type: 'RESTORE_FOCUS_TIMER',\n      //     timerState: activeTimer\n      //   }).catch(err => {\n      //     console.log('Tab not ready yet, will use script injection instead');\n      //     // Use script injection as fallback\n      //     ensureTimerVisibility();\n      //   });\n      // }\n    }, 500);\n  }\n});\n\n// Set default settings on installation/update\nchrome.runtime.onInstalled.addListener(details => {\n  if (details.reason === \"install\") {\n    // First-time install: set defaults\n    chrome.storage.local.set({\n      extensionEnabled: true,\n      autoGroupEnabled: true, // Set auto grouping enabled by default\n      focusState: {\n        active: false,\n        allowedContexts: []\n      },\n      firstRunComplete: false\n    });\n    \n    // Show onboarding page\n    chrome.tabs.create({ url: chrome.runtime.getURL(\"onboarding.html\") });\n  } else if (details.reason === \"update\") {\n    // Handle migration from old storage format to new\n    chrome.storage.local.get([\n      \"autoGroupEnabled\", // Check for this setting\n      \"focusSessionActive\", \n      \"focusSessionEndTime\",\n      \"blockedCategories\",\n      \"focusState\"\n    ], result => {\n      // Always set extension to enabled\n      const update: Record<string, any> = {\n        extensionEnabled: true\n      };\n      \n      // Migration: If we have old format data but no new focusState yet, convert it\n      if (!result.focusState && (result.focusSessionActive || result.blockedCategories)) {\n        console.log(\"Migrating from old focus session format to new focusState format\");\n        \n        // Convert to new FocusState format (invert the block logic to allowedContexts)\n        const knownContexts = [\n          \"Work\", \"Development\", \"Research\", \"Learning\", \n          \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n        ];\n        \n        // Calculate allowed contexts by excluding blocked ones\n        const blockedCategories = result.blockedCategories || [];\n        const allowedContexts = knownContexts.filter(ctx => !blockedCategories.includes(ctx));\n        \n        update.focusState = {\n          active: result.focusSessionActive === true,\n          allowedContexts,\n          endTime: result.focusSessionEndTime || undefined\n        };\n        \n        // Remove old keys after migration\n        chrome.storage.local.remove([\n          \"focusSessionActive\", \n          \"focusSessionEndTime\", \n          \"blockedCategories\"\n        ]);\n      }\n      \n      // Ensure we have explicit boolean values, not undefined  \n      if (result.autoGroupEnabled === undefined) update.autoGroupEnabled = true;\n      \n      // Apply all updates\n      chrome.storage.local.set(update);\n    });\n  }\n});\n\n// Kick off on load\ninitExtension().catch(console.error);","import { getStorage, setStorage } from \"./storageApi\";\nimport { ParkedLink } from \"../types/index\";\n\n/**\n * Save a link for later viewing\n */\nexport async function saveForLater(url: string, context: string, title?: string): Promise<void> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  \n  // Check if the URL is already parked to avoid duplicates\n  const isDuplicate = parkedLinks.some(link => link.url === url);\n  \n  if (!isDuplicate) {\n    const newLink: ParkedLink = {\n      url,\n      title,\n      context,\n      timestamp: Date.now()\n    };\n    \n    await setStorage({\n      parkedLinks: [...parkedLinks, newLink]\n    });\n  }\n}\n\n/**\n * Get all parked links\n */\nexport async function getParkedLinks(): Promise<ParkedLink[]> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  return parkedLinks;\n}\n\n/**\n * Open all parked links in new tabs and clear the list\n */\nexport async function releaseParkedLinks(): Promise<void> {\n  const parkedLinks = await getParkedLinks();\n  \n  if (parkedLinks.length === 0) {\n    return;\n  }\n  \n  // Create a new tab group for the parked links\n  const currentWindow = await chrome.windows.getCurrent();\n  let groupId: number | undefined;\n  \n  try {\n    // Open all the links in new tabs\n    const openedTabIds: number[] = [];\n    \n    for (const link of parkedLinks) {\n      const tab = await chrome.tabs.create({\n        url: link.url,\n        active: false\n      });\n      \n      if (tab.id) {\n        openedTabIds.push(tab.id);\n      }\n    }\n    \n    // Group the tabs if we have any\n    if (openedTabIds.length > 0) {\n      try {\n        groupId = await chrome.tabs.group({\n          tabIds: openedTabIds\n        });\n        \n        if (groupId) {\n          await chrome.tabGroups.update(groupId, {\n            title: \"Parked Links\",\n            color: \"blue\"\n          });\n        }\n      } catch (groupError) {\n        console.error(\"Error creating tab group:\", groupError);\n      }\n    }\n    \n    // Clear the parked links list\n    await setStorage({ parkedLinks: [] });\n    \n    // Show a notification\n    chrome.notifications.create({\n      type: \"basic\",\n      iconUrl: chrome.runtime.getURL(\"icons/icon48.png\"),\n      title: \"Parked Links Opened\",\n      message: `Opened ${parkedLinks.length} links that were saved during your focus session.`\n    });\n  } catch (error) {\n    console.error(\"Error opening parked links:\", error);\n  }\n}\n\n/**\n * More robust function to navigate back or close the current tab\n */\nexport async function goBackOrClose(tabId: number): Promise<void> {\n  try {\n    // Get tab info first to confirm it exists\n    const tab = await chrome.tabs.get(tabId);\n    \n    // First try to determine if we can go back using script injection\n    try {\n      const historyResults = await chrome.scripting.executeScript({\n        target: { tabId },\n        func: () => ({\n          canGoBack: window.history.length > 1,\n          url: window.location.href\n        })\n      });\n      \n      const { canGoBack } = historyResults[0].result;\n      \n      if (canGoBack) {\n        // Navigate back if possible using script injection\n        await chrome.scripting.executeScript({\n          target: { tabId },\n          func: () => window.history.back()\n        });\n        \n        // Success, we're done\n        return;\n      }\n      \n      // Can't go back, use fallback approach\n      await handleNavigationFallback(tabId, tab);\n    } catch (err) {\n      console.error(\"Script execution error:\", err);\n      \n      // Fallback to simpler chrome.tabs.goBack API\n      try {\n        await chrome.tabs.goBack(tabId);\n      } catch (backError) {\n        // If that fails too, use final fallback\n        await handleNavigationFallback(tabId, tab);\n      }\n    }\n  } catch (err) {\n    console.error(\"Tab lookup error:\", err);\n    // Tab might no longer exist, nothing to do\n  }\n}\n\n/**\n * Fallback navigation handler when going back isn't possible\n */\nasync function handleNavigationFallback(tabId: number, tab: chrome.tabs.Tab): Promise<void> {\n  try {\n    // Get all tabs in the window\n    const allTabs = await chrome.tabs.query({ windowId: tab.windowId });\n    \n    if (allTabs.length > 1) {\n      // More than one tab, find one to focus\n      const currentIndex = allTabs.findIndex(t => t.id === tabId);\n      const targetIndex = currentIndex > 0 ? currentIndex - 1 : (currentIndex + 1) % allTabs.length;\n      const targetTab = allTabs[targetIndex];\n      \n      // Focus the other tab first\n      if (targetTab.id) {\n        await chrome.tabs.update(targetTab.id, { active: true });\n        \n        // Then remove the current tab\n        setTimeout(() => {\n          chrome.tabs.remove(tabId).catch(e => {\n            console.error(\"Tab removal failed:\", e);\n          });\n        }, 100);\n      }\n    } else {\n      // Last tab, navigate to blank page instead\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    }\n  } catch (e) {\n    console.error(\"Navigation fallback failed:\", e);\n    // Last resort - try basic navigation\n    try {\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    } catch (finalError) {\n      console.error(\"Final fallback failed:\", finalError);\n    }\n  }\n}\n\n/**\n * Show a toast notification in the current tab\n */\nexport async function showToast(tabId: number, message: string, duration = 3000): Promise<void> {\n  try {\n    await chrome.scripting.executeScript({\n      target: { tabId },\n      func: (msg: string, dur: number) => {\n        const toast = document.createElement(\"div\");\n        toast.style.cssText = `\n          position: fixed;\n          bottom: 20px;\n          right: 20px;\n          background-color: rgba(0, 102, 204, 0.9);\n          color: white;\n          padding: 12px 20px;\n          border-radius: 4px;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n          font-family: Arial, sans-serif;\n          z-index: 2147483647;\n          max-width: 300px;\n          transition: opacity 0.3s ease-in-out;\n        `;\n        toast.textContent = msg;\n        document.body.appendChild(toast);\n        \n        // Fade out and remove\n        setTimeout(() => {\n          toast.style.opacity = \"0\";\n          setTimeout(() => toast.remove(), 300);\n        }, dur - 300);\n      },\n      args: [message, duration]\n    });\n  } catch (error) {\n    console.error(\"Error showing toast:\", error);\n  }\n}\n\n/**\n * Clear all parked links without opening them\n */\nexport async function clearParkedLinks(): Promise<void> {\n  await setStorage({ parkedLinks: [] });\n} ","import { pickColorForContext } from \"../lib/pickColor\";\n\nexport async function groupTabByContext(tabId: number, context: string): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  let existingGroup = groups.find((grp) => grp.title === context);\n\n  if (!existingGroup) {\n    // Create new group if none match\n    const newGroupId = await chrome.tabs.group({ tabIds: [tabId] });\n    existingGroup = await chrome.tabGroups.update(newGroupId, {\n      title: context,\n      color: pickColorForContext(context),\n    });\n  } else {\n    // Add to existing group\n    await chrome.tabs.group({ groupId: existingGroup.id, tabIds: [tabId] });\n  }\n}\n\nexport function onTabRemoved(callback: (tabId: number) => void): void {\n  chrome.tabs.onRemoved.addListener(callback);\n}\n\n/** Ungroup every tab in every window */\nexport async function ungroupAllTabs(): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  for (const g of groups) {\n    const tabs = await chrome.tabs.query({ groupId: g.id });\n    if (tabs.length) {\n      await chrome.tabs.ungroup(tabs.map(t => t.id!));\n    }\n  }\n}","import { getStorage, setStorage } from \"./storageApi\";\nimport { FocusStatus, FocusSettings, ContextSwitch } from \"../types/index\";\n\nconst DEFAULT_FOCUS_SETTINGS: FocusSettings = {\n  enabled: true,\n  notificationsEnabled: true,\n  switchThreshold: 5,\n  timeWindowMinutes: 15\n};\n\n/**\n * Get the current focus settings\n */\nexport async function getFocusSettings(): Promise<FocusSettings> {\n  const { focusSettings } = await getStorage([\"focusSettings\"]);\n  return { ...DEFAULT_FOCUS_SETTINGS, ...focusSettings };\n}\n\n/**\n * Update focus settings\n */\nexport async function updateFocusSettings(settings: Partial<FocusSettings>): Promise<void> {\n  const currentSettings = await getFocusSettings();\n  await setStorage({ \n    focusSettings: { ...currentSettings, ...settings } \n  });\n}\n\n/**\n * Get context switches in a time window\n */\nexport async function getContextSwitches(timeWindowMinutes: number = 15): Promise<ContextSwitch[]> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (!contextHistory || contextHistory.length < 2) {\n    return [];\n  }\n  \n  const switches: ContextSwitch[] = [];\n  const now = Date.now();\n  const timeWindow = timeWindowMinutes * 60 * 1000;\n  \n  // Filter history to time window\n  const relevantHistory = contextHistory.filter(\n    entry => (now - entry.timestamp) < timeWindow\n  );\n  \n  // Find context switches\n  for (let i = 1; i < relevantHistory.length; i++) {\n    if (relevantHistory[i].context !== relevantHistory[i-1].context) {\n      switches.push({\n        from: relevantHistory[i-1].context,\n        to: relevantHistory[i].context,\n        timestamp: relevantHistory[i].timestamp,\n        fromUrl: relevantHistory[i-1].url,\n        toUrl: relevantHistory[i].url\n      });\n    }\n  }\n  \n  return switches;\n}\n\n/**\n * Check if focus is lost based on context switching\n */\nexport async function checkFocusStatus(): Promise<FocusStatus> {\n  const settings = await getFocusSettings();\n  const switches = await getContextSwitches(settings.timeWindowMinutes);\n  \n  let currentContext = \"Unknown\";\n  let currentStreak = 1;\n  \n  // Get most recent context and streak\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (contextHistory && contextHistory.length > 0) {\n    currentContext = contextHistory[contextHistory.length - 1].context;\n    \n    // Count consecutive entries with same context\n    let i = contextHistory.length - 1;\n    while (i > 0 && contextHistory[i].context === currentContext) {\n      currentStreak++;\n      i--;\n    }\n  }\n  \n  // Determine if focus is lost\n  const isLostFocus = switches.length >= settings.switchThreshold;\n  \n  return {\n    isLostFocus,\n    contextSwitches: switches,\n    currentStreak,\n    currentContext\n  };\n}\n\n/**\n * Show focus notification\n */\nexport function showFocusNotification(contextSwitches: ContextSwitch[]): void {\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Alert',\n    message: `You've switched contexts ${contextSwitches.length} times recently. Try to maintain focus.`,\n    buttons: [\n      { title: 'View Details' }\n    ]\n  });\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(545);\n"],"names":["getStorage","keys","Promise","resolve","reject","chrome","storage","local","get","result","runtime","lastError","setStorage","data","set","async","getFocusState","focusState","active","allowedContexts","context","url","confidence","contextHistory","newHistory","push","timestamp","Date","now","length","shift","partialState","currentState","focusWindowId","launchFocusWindow","undefined","windows","error","id","create","type","state","tabs","query","windowId","update","getURL","console","remove","tabId","move","index","blockClearTimer","endTimeCheckInterval","recentlyBlocked","end","setFocusState","endTime","action","setBadgeText","text","clearInterval","clearTimeout","allowed","durationMin","safeAllowed","Array","isArray","setBadgeBackgroundColor","color","setInterval","log","notifications","iconUrl","title","message","priority","includes","setTimeout","timeLeftMs","Math","max","floor","currentWindow","getCurrent","sidePanel","open","panels","getAll","all","map","panel","close","path","setOptions","enabled","alarmListenerRegistered","updateBadge","timeLeftMin","drifting","ceil","toString","setIcon","getFocusSessionTimeLeft","diff","saveCurrentWorkspace","name","groups","tabGroups","workspaceGroups","grp","groupId","tabUrls","t","savedWorkspaces","newWorkspaceEntry","updatedWorkspaces","durationMinutes","blockedCategories","filter","ctx","openSidePanel","alarms","periodInMinutes","onAlarm","addListener","alarm","focusSettings","response","sendMessage","isLostFocus","checkIfDrifting","focusWindowEnabled","saveWorkspace","workspaceName","closeSidePanel","ungroupAllTabs","clear","closeFocusWindow","releaseParkedLinks","detectedCategory","workspace","find","ws","tabIds","createdTab","newGroupId","group","tabContextMap","BLOCKED_PAGE_URL","focusTimeLeft","focusEngine","getTimeLeft","minutesLeft","checkFocusStatus","focusStatus","switchCount","contextSwitches","checkFocusSessionStatus","isActive","getContextData","contexts","training","falsePositives","truePositives","saveContextData","onMessage","request","sender","sendResponse","tab","secondaryContexts","autoGroupEnabled","groupTabByContext","handleContextUpdate","catch","err","toggleFocusMode","payload","start","then","success","seconds","restoreWorkspace","resp","saveForLater","String","actualContext","predictedContext","isFalsePositive","contextData","weights","forEach","fp","tp","updateContextWeights","goBackOrClose","e","Error","onTabRemoved","removedTabId","onUpdated","changeInfo","status","startsWith","onInstalled","details","reason","extensionEnabled","firstRunComplete","focusSessionActive","knownContexts","focusSessionEndTime","toLocaleTimeString","isBlocked","checkIfUrlShouldBeBlocked","activeTab","lastSwitch","from","to","requireInteraction","sendDriftWarning","initExtension","getParkedLinks","parkedLinks","handleNavigationFallback","allTabs","currentIndex","findIndex","targetTab","finalError","some","link","newLink","openedTabIds","groupError","historyResults","scripting","executeScript","target","func","canGoBack","window","history","location","href","back","goBack","backError","duration","msg","dur","toast","document","createElement","style","cssText","textContent","body","appendChild","opacity","args","existingGroup","pickColorForContext","callback","onRemoved","g","ungroup","DEFAULT_FOCUS_SETTINGS","notificationsEnabled","switchThreshold","timeWindowMinutes","getFocusSettings","getContextSwitches","switches","timeWindow","relevantHistory","entry","i","fromUrl","toUrl","settings","currentSettings","currentContext","currentStreak","buttons","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}