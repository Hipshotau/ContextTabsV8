{"version":3,"file":"background.js","mappings":"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","sources":["webpack://context-focus/./src/api/storageApi.ts","webpack://context-focus/./src/lib/windows/focusWindow.ts","webpack://context-focus/./src/lib/pickColor.ts","webpack://context-focus/./src/lib/focusEngine.ts","webpack://context-focus/./src/lib/panels/sidePanelManager.ts","webpack://context-focus/./src/background/index.ts","webpack://context-focus/./src/api/parkedLinksApi.ts","webpack://context-focus/./src/api/tabsApi.ts","webpack://context-focus/./src/api/focusApi.ts","webpack://context-focus/./src/background/blockingRules.ts","webpack://context-focus/webpack/bootstrap","webpack://context-focus/webpack/startup"],"sourcesContent":["import { FocusSettings, StorageData as TypesStorageData, FocusState } from \"../types/index\";\n\n// Re-export the StorageData interface from types/index.d.ts\nexport type StorageData = TypesStorageData;\n\n/**\n * Get an object containing the requested keys.\n */\nexport function getStorage<T extends keyof StorageData>(\n  keys: T[]\n): Promise<Pick<StorageData, T>> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.get(keys, (result) => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve(result as Pick<StorageData, T>);\n    });\n  });\n}\n\n/**\n * Set or update the given keys in storage.\n */\nexport function setStorage(data: Partial<StorageData>): Promise<void> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.set(data, () => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * Add a context entry to history\n */\nexport async function addContextToHistory(\n  context: string,\n  url: string,\n  confidence: number\n): Promise<void> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  const newHistory = contextHistory || [];\n  \n  // Add new entry\n  newHistory.push({\n    context,\n    url,\n    timestamp: Date.now(),\n    confidence\n  });\n  \n  // Limit history size\n  if (newHistory.length > 100) {\n    newHistory.shift();\n  }\n  \n  await setStorage({ contextHistory: newHistory });\n}\n\n/**\n * Get the current focus state\n */\nexport async function getFocusState(): Promise<FocusState> {\n  const { focusState } = await getStorage([\"focusState\"]);\n  \n  // Default state if none exists\n  const defaultState: FocusState = {\n    active: false,\n    allowedContexts: []\n  };\n  \n  return { ...defaultState, ...focusState };\n}\n\n/**\n * Update the focus state\n */\nexport async function setFocusState(partialState: Partial<FocusState>): Promise<void> {\n  const currentState = await getFocusState();\n  await setStorage({ \n    focusState: { ...currentState, ...partialState }\n  });\n}","let focusWindowId: number | undefined;\n\n/**\n * Create a dedicated window for the focus session\n * This creates a new window that can be populated with productive tabs\n */\nexport async function launchFocusWindow(): Promise<number | undefined> {\n  try {\n    // Check if focus window already exists\n    if (focusWindowId !== undefined) {\n      try {\n        // Try to get window to verify it still exists\n        await chrome.windows.get(focusWindowId);\n        return focusWindowId; // Window already exists\n      } catch (error) {\n        // Window doesn't exist anymore, reset the ID\n        focusWindowId = undefined;\n      }\n    }\n\n    // Create a new window\n    const { id } = await chrome.windows.create({\n      url: \"about:blank\",\n      type: \"normal\",\n      state: \"maximized\"\n    });\n    \n    focusWindowId = id;\n    \n    // Create a welcoming tab\n    if (id) {\n      const tabs = await chrome.tabs.query({ windowId: id });\n      \n      // If there's at least one tab (the default about:blank), update it\n      if (tabs.length > 0 && tabs[0].id) {\n        await chrome.tabs.update(tabs[0].id, { \n          url: chrome.runtime.getURL(\"blocked.html\") + \"?mode=welcome\" \n        });\n      }\n    }\n    \n    return focusWindowId;\n  } catch (error) {\n    console.error(\"Error launching focus window:\", error);\n    return undefined;\n  }\n}\n\n/**\n * Close the dedicated focus window\n */\nexport async function closeFocusWindow(): Promise<void> {\n  if (focusWindowId === undefined) return;\n  \n  try {\n    await chrome.windows.remove(focusWindowId);\n    focusWindowId = undefined;\n  } catch (error) {\n    console.error(\"Error closing focus window:\", error);\n    // Reset the ID even if there was an error\n    focusWindowId = undefined;\n  }\n}\n\n/**\n * Check if the focus window is active\n */\nexport function getFocusWindowId(): number | undefined {\n  return focusWindowId;\n}\n\n/**\n * Move a tab to the focus window\n */\nexport async function moveTabToFocusWindow(tabId: number): Promise<boolean> {\n  if (focusWindowId === undefined) {\n    const windowId = await launchFocusWindow();\n    if (windowId === undefined) return false;\n  }\n  \n  try {\n    await chrome.tabs.move(tabId, { windowId: focusWindowId!, index: -1 });\n    return true;\n  } catch (error) {\n    console.error(\"Error moving tab to focus window:\", error);\n    return false;\n  }\n} ","export function pickColorForContext(context: string): chrome.tabGroups.ColorEnum {\n  switch (context) {\n    case \"Work\":\n      return \"yellow\";\n    case \"Learning\":\n      return \"blue\";\n    case \"Entertainment\":\n      return \"green\";\n    case \"News\":\n      return \"red\";\n    case \"Shopping\":\n      return \"purple\";\n    case \"Social\":\n      return \"cyan\";\n    case \"Research\":\n      return \"pink\";\n    case \"Development\":\n      return \"orange\";\n    default:\n      return \"grey\";  // Chrome uses \"grey\" (British spelling) not \"gray\"\n  }\n}","/**\n * Focus Engine - Core logic for the Focus feature\n * \n * This module implements the state machine for focus mode, following the principle\n * of \"block by exclusion\" - where user picks ALLOWED contexts and everything else is blocked.\n */\n\nimport { getFocusState, setFocusState, getStorage, setStorage } from \"../api/storageApi\";\nimport { FocusState } from \"../types/index\";\nimport { openSidePanel, closeSidePanel } from \"../lib/panels/sidePanelManager\";\nimport { launchFocusWindow, closeFocusWindow } from \"../lib/windows/focusWindow\";\nimport { releaseParkedLinks } from \"../api/parkedLinksApi\";\nimport { ungroupAllTabs } from \"../api/tabsApi\";\n\n// State for tracking if a navigation was blocked recently (for badge alert)\nlet recentlyBlocked = false;\nlet blockClearTimer: NodeJS.Timeout | undefined;\n\n/**\n * Start a focus session\n * \n * @param allowed - Array of context categories that are allowed during focus\n * @param durationMin - Optional duration in minutes after which focus will automatically end\n */\nexport async function start(allowed: string[], durationMin?: number): Promise<void> {\n  // Safety check for allowed contexts\n  const safeAllowed = Array.isArray(allowed) ? allowed : [];\n  \n  // Calculate end time if duration is provided\n  const endTime = durationMin ? Date.now() + durationMin * 60 * 1000 : undefined;\n  \n  // Save focus state\n  await setFocusState({\n    active: true,\n    allowedContexts: safeAllowed,\n    endTime\n  });\n  \n  // Store blockedCategories for backward compatibility\n  const knownContexts = [\n    \"Work\", \"Development\", \"Research\", \"Learning\", \n    \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n  ];\n  const blockedCategories = knownContexts.filter(ctx => !safeAllowed.includes(ctx));\n  await setStorage({ blockedCategories });\n  \n  // Open the side panel for persistent timer display\n  await openSidePanel();\n  \n  // Check if focus window is enabled and launch if needed\n  const storage = await getStorage([\"focusSettings\"]);\n  const focusWindowEnabled = storage.focusSettings?.focusWindowEnabled || false;\n  if (focusWindowEnabled) {\n    await launchFocusWindow();\n  }\n  \n  // Set badge to show focus is active\n  chrome.action.setBadgeText({ text: \"•\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n  \n  // Show notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Started',\n    message: durationMin ? \n      `Focus session started for ${durationMin} minutes. Stay focused!` :\n      'Focus session started. Stay focused!',\n    priority: 2\n  });\n}\n\n/**\n * End a focus session\n * @param saveWorkspaceName - Optional workspace name to save current tab groups\n */\nexport async function end(saveWorkspaceName?: string): Promise<void> {\n  // If user wants to save workspace, store it\n  if (saveWorkspaceName) {\n    try {\n      // Get all tab groups\n      const groups = await chrome.tabGroups.query({});\n      // For each group, gather tab URLs\n      const workspaceGroups = await Promise.all(\n        groups.map(async (grp) => {\n          const tabs = await chrome.tabs.query({ groupId: grp.id });\n          return {\n            groupId: grp.id,\n            title: grp.title || \"\",\n            color: grp.color,\n            tabUrls: tabs.map(t => t.url || \"\")\n          };\n        })\n      );\n\n      // Store in savedWorkspaces\n      const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n      const newWorkspaceEntry = {\n        name: saveWorkspaceName,\n        tabGroups: workspaceGroups,\n        timestamp: Date.now()\n      };\n\n      const updatedWorkspaces = Array.isArray(savedWorkspaces) \n        ? [...savedWorkspaces, newWorkspaceEntry]\n        : [newWorkspaceEntry];\n\n      await setStorage({ savedWorkspaces: updatedWorkspaces });\n    } catch (error) {\n      console.error(\"Error saving workspace:\", error);\n    }\n  }\n  \n  // Clear focus state\n  await setFocusState({\n    active: false,\n    endTime: undefined\n  });\n  \n  // Close UI components\n  await closeSidePanel();\n  await closeFocusWindow();\n  await ungroupAllTabs();\n  \n  // Clear badge\n  chrome.action.setBadgeText({ text: \"\" });\n  \n  // Reset block indicator\n  recentlyBlocked = false;\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n    blockClearTimer = undefined;\n  }\n  \n  // Show notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Ended',\n    message: 'Your focus session has ended. Great job!',\n    priority: 2\n  });\n  \n  // Release any links that were parked during the session\n  await releaseParkedLinks();\n}\n\n/**\n * Check if a context should be blocked\n * \n * @param context - The context category to check\n * @returns true if the context should be blocked, false otherwise\n */\nexport async function isBlocked(context: string): Promise<boolean> {\n  const focusState = await getFocusState();\n  \n  // If focus is not active, nothing is blocked\n  if (!focusState.active) {\n    return false;\n  }\n  \n  // Safety check: ensure allowedContexts is an array before using includes\n  if (!Array.isArray(focusState.allowedContexts)) {\n    console.error(\"[FocusEngine] allowedContexts is not an array:\", focusState.allowedContexts);\n    return false; // Fail open rather than blocking everything\n  }\n  \n  // Add logging to help debug\n  console.log(\"[FocusEngine] allowed:\", focusState.allowedContexts, \"context:\", context);\n  \n  // If context is in allowed list, it's not blocked\n  if (focusState.allowedContexts.includes(context)) {\n    return false;\n  }\n  \n  // Context is not in allowed list, so it's blocked\n  // Update the \"recently blocked\" state for badge\n  recentlyBlocked = true;\n  \n  // Show red \"!\" badge\n  chrome.action.setBadgeText({ text: \"!\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red\n  \n  // Clear the blocked indicator after 30 seconds\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n  }\n  \n  blockClearTimer = setTimeout(() => {\n    if (recentlyBlocked) {\n      recentlyBlocked = false;\n      // Restore the normal focus badge\n      chrome.action.setBadgeText({ text: \"•\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n    }\n  }, 30000);\n  \n  return true;\n}\n\n/**\n * Check if a focus session is currently active\n * \n * @returns true if a focus session is active, false otherwise\n */\nexport async function isActive(): Promise<boolean> {\n  const focusState = await getFocusState();\n  return focusState.active;\n}\n\n/**\n * Get the time left in the current focus session in seconds\n * \n * @returns Seconds left in the focus session, or -1 if no timer (unlimited session)\n */\nexport async function getTimeLeft(): Promise<number> {\n  const { active, endTime } = await getFocusState();\n  if (!active) return 0; // Not active, no time\n  if (!endTime) return -1; // -1 = unlimited/indefinite session\n  return Math.max(0, endTime - Date.now()) / 1000; // seconds\n}\n\n/**\n * Restore a saved workspace by name. \n * Re-open tabs and re-create groups (approximation).\n */\nexport async function restoreWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const workspace = savedWorkspaces.find(ws => ws.name === name);\n  if (!workspace) return;\n\n  // For each group, re-create tabs\n  for (const grp of workspace.tabGroups) {\n    // Open each tab\n    const tabIds = [];\n    for (const url of grp.tabUrls) {\n      const createdTab = await chrome.tabs.create({ url, active: false });\n      tabIds.push(createdTab.id as number);\n    }\n    // Create or update tab group\n    if (tabIds.length > 0) {\n      const newGroupId = await chrome.tabs.group({ tabIds });\n      await chrome.tabGroups.update(newGroupId, {\n        title: grp.title || \"\",\n        color: grp.color\n      });\n    }\n  }\n}\n\n/**\n * Save current window's tab groups (workspace).\n * This can be called at the end of a Focus Session or on demand.\n */\nexport async function saveCurrentWorkspace(name: string): Promise<void> {\n  // Get all tab groups\n  const groups = await chrome.tabGroups.query({});\n  // For each group, gather tab URLs\n  const workspaceGroups = await Promise.all(\n    groups.map(async (grp) => {\n      const tabs = await chrome.tabs.query({ groupId: grp.id });\n      return {\n        groupId: grp.id,\n        title: grp.title || \"\",\n        color: grp.color,\n        tabUrls: tabs.map(t => t.url || \"\")\n      };\n    })\n  );\n\n  // Store in savedWorkspaces\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  const newWorkspaceEntry = {\n    name,\n    tabGroups: workspaceGroups,\n    timestamp: Date.now()\n  };\n\n  const updatedWorkspaces = Array.isArray(savedWorkspaces) \n    ? [...savedWorkspaces, newWorkspaceEntry]\n    : [newWorkspaceEntry];\n\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n}\n\n/**\n * Clean up old workspace entries if needed, or remove a workspace by name, etc.\n */\nexport async function removeWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const updatedWorkspaces = savedWorkspaces.filter(ws => ws.name !== name);\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n} ","/**\n * Open the side panel in the current window\n */\nexport async function openSidePanel(): Promise<void> {\n  try {\n    const currentWindow = await chrome.windows.getCurrent();\n    await chrome.sidePanel.open({ windowId: currentWindow.id });\n    console.log(\"Side panel opened successfully\");\n  } catch (error) {\n    console.error(\"Error opening side panel:\", error);\n  }\n}\n\n/**\n * Close the side panel in all windows\n */\nexport async function closeSidePanel(): Promise<void> {\n  try {\n    const panels = await chrome.sidePanel.getAll();\n    await Promise.all(panels.map((panel: chrome.sidePanel.PanelInfo) => \n      chrome.sidePanel.close({ windowId: panel.windowId })\n    ));\n    console.log(\"Side panels closed successfully\");\n  } catch (error) {\n    console.error(\"Error closing side panels:\", error);\n  }\n}\n\n/**\n * Set the side panel properties\n */\nexport async function setSidePanelProperties(path: string, title: string): Promise<void> {\n  try {\n    await chrome.sidePanel.setOptions({\n      path,\n      enabled: true\n    });\n    console.log(\"Side panel properties updated\");\n  } catch (error) {\n    console.error(\"Error setting side panel properties:\", error);\n  }\n} ","import { groupTabByContext, onTabRemoved, ungroupAllTabs } from \"../api/tabsApi\";\nimport { getStorage, setStorage, getFocusState, setFocusState } from \"../api/storageApi\";\nimport { checkFocusStatus, showFocusNotification } from \"../api/focusApi\";\nimport { classifyPageContext } from \"../lib/contextEngine\";\nimport { extractDomain } from \"../lib/contextEngine/urlAnalyzer\";\nimport { saveForLater, releaseParkedLinks, goBackOrClose } from \"../api/parkedLinksApi\";\nimport * as focusEngine from \"../lib/focusEngine\";\nimport { applyAllowedContexts } from \"./blockingRules\";\n\nconst tabContextMap: Record<number, string> = {};\nconst BLOCKED_PAGE_URL = chrome.runtime.getURL(\"blocked.html\");\n\n/**\n * Initialize the extension with proper default settings\n */\nasync function initExtension(): Promise<void> {\n  // Always enable the extension\n  await setStorage({ extensionEnabled: true });\n  \n  console.log(\"[Background] Extension enabled.\");\n  \n  // Check for active sessions - now using the new focusState\n  const focusState = await getFocusState();\n  if (focusState.active) {\n    console.log(\"[Background] Focus session was active at shutdown, verifying...\");\n    // Verify session is still valid (not expired)\n    if (!focusState.endTime || focusState.endTime <= Date.now()) {\n      console.log(\"[Background] Focus session expired during shutdown, cleaning up\");\n      await setFocusState({ active: false, endTime: undefined });\n    } else {\n      console.log(`[Background] Focus session continues until ${new Date(focusState.endTime).toLocaleTimeString()}`);\n      \n      // Apply blocking rules for active focus session\n      await applyAllowedContexts();\n    }\n  }\n  \n  // Set up periodic checks\n  setupPeriodicChecks();\n}\n\n/**\n * Set up all periodic checks needed for the extension\n */\nfunction setupPeriodicChecks() {\n  // Set up alarms for periodic checks - minimum 1 minute for MV3\n  chrome.alarms.create('focusTick', { periodInMinutes: 1 });     // 60s - check session status\n  chrome.alarms.create('focusDrift', { periodInMinutes: 2 });    // 120s - check drift (less urgent)\n  \n  // Handle alarms\n  chrome.alarms.onAlarm.addListener(async ({ name }) => {\n    try {\n      if (name === 'focusTick') {\n        await checkFocusSessionStatus();\n      } else if (name === 'focusDrift') {\n        const isSessionActive = await focusEngine.isActive();\n        if (isSessionActive) {\n          const focusStatus = await checkFocusStatus();\n          if (focusStatus.isLostFocus) {\n            // Immediately send a drift warning if focus is lost\n            await sendDriftWarning(focusStatus);\n          }\n        }\n      }\n      // Update badge for all alarm types\n      await updateBadge();\n    } catch (err) {\n      console.error(`Error in alarm handler (${name}):`, err);\n    }\n  });\n}\n\n/**\n * Handle messages from content scripts and the UI\n */\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.type === \"CONTEXT_UPDATE\" || request.type === \"CONTEXT_DETECTED\") {\n    const context = request.context as string;\n    const tabId = sender.tab?.id;\n    \n    if (tabId != null) {\n      // Check if context has changed\n      const previousContext = tabContextMap[tabId];\n      if (previousContext !== context) {\n        // Notify focus mode about context change\n        // handleContextChange(context);\n      }\n      \n      tabContextMap[tabId] = context;\n      \n      // Store additional context data if available\n      const contextData = {\n        context,\n        confidence: request.confidence,\n        secondaryContexts: request.secondaryContexts,\n        url: request.url\n      };\n      \n      // Save context data to storage for URL blocking functionality\n      chrome.storage.local.set({\n        [request.url]: { context: request.context, confidence: request.confidence }\n      });\n      \n      // Handle the context update\n      handleContextUpdate(tabId, context, contextData).catch((err) => console.error(err));\n    }\n    \n    return false; // No response needed\n  } \n  else if (request.type === \"FOCUS_TOGGLE\") {\n    toggleFocusMode(request.enabled).catch((err) => console.error(err));\n    return false; // No response needed\n  }\n  else if (request.type === \"START_FOCUS_SESSION\") {\n    const { durationMinutes, allowedContexts } = request.payload || {};\n    \n    // Use allowedContexts directly if provided, otherwise fallback to blockedCategories\n    if (allowedContexts) {\n      focusEngine.start(allowedContexts, durationMinutes)\n        .then(() => sendResponse({ success: true }))\n        .catch((err) => {\n          console.error(err);\n          sendResponse({ success: false, error: err.message });\n        });\n    } else {\n      // Legacy support: convert blockedCategories to allowedContexts\n      const { blockedCategories } = request.payload || {};\n      const KNOWN_CONTEXTS = [\n        \"Work\", \"Development\", \"Research\", \"Learning\",\n        \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n      ];\n      const allowedContexts = KNOWN_CONTEXTS.filter(\n        ctx => !blockedCategories?.includes(ctx)\n      );\n      \n      focusEngine.start(allowedContexts, durationMinutes)\n        .then(() => sendResponse({ success: true }))\n        .catch((err) => {\n          console.error(err);\n          sendResponse({ success: false, error: err.message });\n        });\n    }\n    return true; // Indicates async response\n  }\n  else if (request.type === \"END_FOCUS_SESSION\") {\n    const { saveWorkspaceName } = request.payload || {};\n    focusEngine.end(saveWorkspaceName)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(\"Error ending focus session:\", err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"GET_FOCUS_TIME_LEFT\") {\n    focusEngine.getTimeLeft()\n      .then(seconds => {\n        sendResponse({ seconds });\n      })\n      .catch(error => {\n        console.error(\"Error getting focus time left:\", error);\n        sendResponse({ seconds: 0 });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"OVERRIDE_BLOCK\") {\n    // Allow explicit override\n    // Just respond with success, this would unblock the tab \n    // if we had a temporary block list\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"RESTORE_WORKSPACE\") {\n    const { name } = request.payload || {};\n    focusEngine.restoreWorkspace(name)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Indicates async response\n  }\n  else if (request.type === \"CHECK_FOCUS_STATUS\") {\n    checkFocusStatus()\n      .then(result => sendResponse(result))\n      .catch(error => {\n        console.error(\"Error checking focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"CONTENT_SCRIPT_READY\") {\n    // Content script is ready to receive messages\n    const tabId = sender.tab?.id;\n    // if (tabId && activeTimer && activeTimer.active && activeTimer.endTime > Date.now()) {\n    //   console.log(`Tab ${tabId} is ready, sending active timer`);\n    //   // Send the timer right away\n    //   chrome.tabs.sendMessage(tabId, {\n    //     type: \"RESTORE_FOCUS_TIMER\",\n    //     timerState: activeTimer\n    //   }).catch(err => {\n    //     console.log('Tab not fully ready, will retry');\n    //     // Try again after a short delay\n    //     setTimeout(() => {\n    //       chrome.tabs.sendMessage(tabId, {\n    //         type: 'RESTORE_FOCUS_TIMER',\n    //         timerState: activeTimer\n    //       }).catch(err => console.error('Failed to restore timer after content script ready retry:', err));\n    //     }, 500);\n    //   });\n    // }\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"TIMER_EXPIRED\") {\n    // Handle timer expiration from the side panel\n    // endFocusTimer();\n    // Show a drift warning on the current page\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      if (tabs[0] && tabs[0].id) {\n        chrome.tabs.sendMessage(tabs[0].id, {\n          type: \"DRIFT_WARNING\",\n          message: \"Time's up! Return to your primary task now.\"\n        }, (resp) => {\n          if (chrome.runtime.lastError || resp === undefined) {\n            // Nobody listened - fall back to the blocked page\n            chrome.tabs.update(tabs[0].id!, {url: BLOCKED_PAGE_URL});\n          }\n        });\n      }\n    });\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"PARK_LINK\") {\n    const { url, context, title } = request;\n    \n    // Handle the parked link asynchronously\n    (async () => {\n      try {\n        await saveForLater(url, context, title);\n        console.log(`[Parked Links] Saved for later: ${title || url} (${context})`);\n      } catch (error) {\n        console.error(\"Error parking link:\", error);\n      }\n    })();\n    \n    return false; // No response needed\n  }\n  else if (request.type === \"RELEASE_PARKED_LINKS\") {\n    // Handle the release of parked links asynchronously\n    (async () => {\n      try {\n        await releaseParkedLinks();\n        sendResponse({ success: true });\n      } catch (error) {\n        console.error(\"Error releasing parked links:\", error);\n        sendResponse({ success: false, error: String(error) });\n      }\n    })();\n    \n    return true; // Indicates async response\n  }\n  else if (request.type === \"TRAIN_CONTEXT\") {\n    (async () => {\n      const { url, title, actualContext, predictedContext, isFalsePositive } = request;\n      \n      // Get or create context data for this URL\n      const contextData = await getContextData(url);\n      \n      // Update training data\n      if (!contextData.training) {\n        contextData.training = {\n          falsePositives: [],\n          truePositives: []\n        };\n      }\n      \n      if (isFalsePositive) {\n        contextData.training.falsePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      } else {\n        contextData.training.truePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      }\n      \n      // Save updated context data\n      await saveContextData(url, contextData);\n      \n      // Recalculate context weights based on training data\n      await updateContextWeights(url);\n      \n      sendResponse({ success: true });\n    })();\n    return true; // Required for async response\n  }\n  else if (request.type === \"STAY_FOCUSED_ACTION\") {\n    (async () => {\n      const { url, context, title } = request.payload;\n      try {\n        await saveForLater(url, context, title);\n        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (tab?.id) await goBackOrClose(tab.id);\n        sendResponse({ success: true });\n      } catch (e: unknown) {\n        console.error(\"Stay‑focused flow failed:\", e);\n        sendResponse({ \n          success: false, \n          error: e instanceof Error ? e.message : String(e)\n        });\n      }\n    })();\n    return true;\n  }\n  else if (request.type === \"FOCUS_STATUS\") {\n    // Return the current focus state to the popup\n    getFocusState()\n      .then(focusState => sendResponse(focusState))\n      .catch(error => {\n        console.error(\"Error getting focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  \n  return false; // No response needed for other messages\n});\n\n/**\n * Handle any focus mode toggle (enable/disable)\n */\nasync function toggleFocusMode(enabled: boolean): Promise<void> {\n  // This is a legacy function, but we'll keep it for compatibility with older UIs\n  if (enabled) {\n    // Legacy function, start with default settings\n    await focusEngine.start([\"Work\", \"Development\", \"Research\", \"Learning\"]);\n    \n    // Apply DNR blocking rules\n    await applyAllowedContexts();\n  } else {\n    // Turn off focus mode\n    await focusEngine.end();\n    \n    // Remove all blocking rules\n    await applyAllowedContexts();\n  }\n}\n\n/**\n * Handle context update with enhanced data\n */\nasync function handleContextUpdate(\n  tabId: number, \n  context: string, \n  contextData?: any\n): Promise<void> {\n  // Get current settings\n  const { autoGroupEnabled = true } = await getStorage([\n    \"autoGroupEnabled\",\n  ]);\n\n  // If auto-group is off, do nothing\n  if (autoGroupEnabled === false) {\n    return;\n  }\n\n  // Group tab by context\n  await groupTabByContext(tabId, context);\n  \n  // Update badge when context changes\n  updateBadge();\n}\n\n/**\n * Updates the badge with current focus status\n */\nasync function updateBadge(): Promise<void> {\n  try {\n    const focusState = await getFocusState();\n    \n    // If not in focus mode, clear badge\n    if (!focusState.active) {\n      chrome.action.setBadgeText({ text: \"\" });\n      return;\n    }\n    \n    // Show a simple indicator\n    chrome.action.setBadgeText({ text: \"•\" });\n    chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n  } catch (error) {\n    console.error(\"Error updating badge:\", error);\n  }\n}\n\n/**\n * Send a high-visibility drift warning to the active tab\n */\nasync function sendDriftWarning(focusStatus: any): Promise<void> {\n  try {\n    // Always show warnings during focus sessions regardless of notification settings\n    // This is critical - users need to be alerted when drifting\n    \n    // Check if a focus session is active\n    const isSessionActive = await focusEngine.isActive();\n    if (!isSessionActive) {\n      return; // Only show drift warnings during active focus sessions\n    }\n    \n    console.log(\"[Focus] Sending drift warning to active tab\", focusStatus);\n    \n    // Get the active tab\n    const tabs = await chrome.tabs.query({active: true, currentWindow: true});\n    if (!tabs.length || !tabs[0].id) return;\n\n    const activeTab = tabs[0];\n    const tabId = activeTab.id as number;\n    \n    // Skip chrome:// pages and extension pages\n    if (\n      activeTab.url?.startsWith(\"chrome://\") || \n      activeTab.url?.startsWith(\"chrome-extension://\")\n    ) {\n      return;\n    }\n    \n    // Create a useful message about why focus was lost\n    let message = \"YOU'RE DRIFTING FROM YOUR FOCUS TASK!\";\n    \n    // If we have context switches, mention the last switch\n    if (focusStatus.contextSwitches.length > 0) {\n      const lastSwitch = focusStatus.contextSwitches[focusStatus.contextSwitches.length - 1];\n      message = `FOCUS LOST: Switched from ${lastSwitch.from} to ${lastSwitch.to}`;\n    }\n    \n    // Send the warning with callback to check if handled\n    chrome.tabs.sendMessage(tabId, {\n      type: \"DRIFT_WARNING\",\n      message\n    }, (resp) => {\n      if (chrome.runtime.lastError || resp === undefined) {\n        // Nobody listened - fall back to the blocked page\n        chrome.tabs.update(tabId, {url: BLOCKED_PAGE_URL});\n      }\n    });\n      \n    // Also show a system notification\n    chrome.notifications.create({\n      type: 'basic',\n      iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n      title: 'FOCUS ALERT!',\n      message: message,\n      priority: 2,\n      requireInteraction: true\n    });\n      \n    console.log(\"[Focus] Drift warning sent successfully\");\n  } catch (error) {\n    console.error(\"Error sending drift warning:\", error);\n  }\n}\n\n/**\n * Sets up blocking when a focus session is active\n * This is a no-op now because we use DNR rules for blocking\n */\nfunction setupFocusSessionUrlBlocking(): void {\n  // No action needed - DNR rules handle blocking\n}\n\n/**\n * Check if a focus session should be ended\n */\nasync function checkFocusSessionStatus(): Promise<void> {\n  const endTime = (await getFocusState()).endTime;\n  if (endTime && Date.now() >= endTime) {\n    const active = await focusEngine.isActive();\n    if (active) {\n      // Focus session time is up\n      await focusEngine.end();\n      console.log(\"[Focus] Session ended automatically due to timeout\");\n      \n      // Show notification to user\n      chrome.notifications.create({\n        type: 'basic',\n        iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n        title: 'Focus Session Complete',\n        message: `Your timed focus session has ended.`,\n      });\n    }\n  }\n}\n\n/**\n * Cleanup in-memory reference on tab removal\n */\nonTabRemoved((removedTabId) => {\n  delete tabContextMap[removedTabId];\n});\n\n// Function to get context data for a URL\nasync function getContextData(url: string): Promise<any> {\n  const result = await chrome.storage.local.get([url]);\n  return result[url] || { contexts: [], training: { falsePositives: [], truePositives: [] } };\n}\n\n// Function to save context data for a URL\nasync function saveContextData(url: string, data: any): Promise<void> {\n  await chrome.storage.local.set({ [url]: data });\n}\n\n// Function to update context weights based on training data\nasync function updateContextWeights(url: string): Promise<void> {\n  const contextData = await getContextData(url);\n  const { training } = contextData;\n  \n  if (!training) return;\n  \n  // Calculate weights based on false positives and true positives\n  const weights: { [key: string]: number } = {};\n  \n  // Decrease weight for contexts that frequently cause false positives\n  training.falsePositives.forEach((fp: any) => {\n    weights[fp.predictedContext] = (weights[fp.predictedContext] || 1) * 0.9;\n  });\n  \n  // Increase weight for contexts that are frequently true positives\n  training.truePositives.forEach((tp: any) => {\n    weights[tp.predictedContext] = (weights[tp.predictedContext] || 1) * 1.1;\n  });\n  \n  // Update context weights\n  contextData.weights = weights;\n  await saveContextData(url, contextData);\n}\n\n// Add listeners for focus state changes to update DNR rules\nchrome.storage.onChanged.addListener(async (changes) => {\n  if (changes.focusState) {\n    // Focus state has changed, update DNR rules\n    await applyAllowedContexts();\n  }\n});\n\n// Set default settings on installation/update\nchrome.runtime.onInstalled.addListener(details => {\n  if (details.reason === \"install\") {\n    // First-time install: set defaults\n    chrome.storage.local.set({\n      extensionEnabled: true,\n      autoGroupEnabled: true, // Set auto grouping enabled by default\n      focusState: {\n        active: false,\n        allowedContexts: []\n      },\n      firstRunComplete: false\n    });\n    \n    // Show onboarding page\n    chrome.tabs.create({ url: chrome.runtime.getURL(\"onboarding.html\") });\n  } else if (details.reason === \"update\") {\n    // Handle migration from old storage format to new\n    chrome.storage.local.get([\n      \"autoGroupEnabled\", // Check for this setting\n      \"focusSessionActive\", \n      \"focusSessionEndTime\",\n      \"blockedCategories\",\n      \"focusState\"\n    ], result => {\n      // Always set extension to enabled\n      const update: Record<string, any> = {\n        extensionEnabled: true\n      };\n      \n      // Migration: If we have old format data but no new focusState yet, convert it\n      if (!result.focusState && (result.focusSessionActive || result.blockedCategories)) {\n        console.log(\"Migrating from old focus session format to new focusState format\");\n        \n        // Convert to new FocusState format (invert the block logic to allowedContexts)\n        const knownContexts = [\n          \"Work\", \"Development\", \"Research\", \"Learning\", \n          \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n        ];\n        \n        // Calculate allowed contexts by excluding blocked ones\n        const blockedCategories = result.blockedCategories || [];\n        const allowedContexts = knownContexts.filter(ctx => !blockedCategories.includes(ctx));\n        \n        update.focusState = {\n          active: result.focusSessionActive === true,\n          allowedContexts,\n          endTime: result.focusSessionEndTime || undefined\n        };\n        \n        // Remove old keys after migration\n        chrome.storage.local.remove([\n          \"focusSessionActive\", \n          \"focusSessionEndTime\", \n          \"blockedCategories\"\n        ]);\n      }\n      \n      // Ensure we have explicit boolean values, not undefined  \n      if (result.autoGroupEnabled === undefined) update.autoGroupEnabled = true;\n      \n      // Apply all updates\n      chrome.storage.local.set(update);\n    });\n  }\n});\n\n// Kick off on load\ninitExtension().catch(console.error);","import { getStorage, setStorage } from \"./storageApi\";\nimport { ParkedLink } from \"../types/index\";\n\n/**\n * Save a link for later viewing\n */\nexport async function saveForLater(url: string, context: string, title?: string): Promise<void> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  \n  // Check if the URL is already parked to avoid duplicates\n  const isDuplicate = parkedLinks.some(link => link.url === url);\n  \n  if (!isDuplicate) {\n    const newLink: ParkedLink = {\n      url,\n      title,\n      context,\n      timestamp: Date.now()\n    };\n    \n    await setStorage({\n      parkedLinks: [...parkedLinks, newLink]\n    });\n  }\n}\n\n/**\n * Get all parked links\n */\nexport async function getParkedLinks(): Promise<ParkedLink[]> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  return parkedLinks;\n}\n\n/**\n * Open all parked links in new tabs and clear the list\n */\nexport async function releaseParkedLinks(): Promise<void> {\n  const parkedLinks = await getParkedLinks();\n  \n  if (parkedLinks.length === 0) {\n    return;\n  }\n  \n  // Create a new tab group for the parked links\n  const currentWindow = await chrome.windows.getCurrent();\n  let groupId: number | undefined;\n  \n  try {\n    // Open all the links in new tabs\n    const openedTabIds: number[] = [];\n    \n    for (const link of parkedLinks) {\n      const tab = await chrome.tabs.create({\n        url: link.url,\n        active: false\n      });\n      \n      if (tab.id) {\n        openedTabIds.push(tab.id);\n      }\n    }\n    \n    // Group the tabs if we have any\n    if (openedTabIds.length > 0) {\n      try {\n        groupId = await chrome.tabs.group({\n          tabIds: openedTabIds\n        });\n        \n        if (groupId) {\n          await chrome.tabGroups.update(groupId, {\n            title: \"Parked Links\",\n            color: \"blue\"\n          });\n        }\n      } catch (groupError) {\n        console.error(\"Error creating tab group:\", groupError);\n      }\n    }\n    \n    // Clear the parked links list\n    await setStorage({ parkedLinks: [] });\n    \n    // Show a notification\n    chrome.notifications.create({\n      type: \"basic\",\n      iconUrl: chrome.runtime.getURL(\"icons/icon48.png\"),\n      title: \"Parked Links Opened\",\n      message: `Opened ${parkedLinks.length} links that were saved during your focus session.`\n    });\n  } catch (error) {\n    console.error(\"Error opening parked links:\", error);\n  }\n}\n\n/**\n * More robust function to navigate back or close the current tab\n */\nexport async function goBackOrClose(tabId: number): Promise<void> {\n  try {\n    // Get tab info first to confirm it exists\n    const tab = await chrome.tabs.get(tabId);\n    \n    // First try to determine if we can go back using script injection\n    try {\n      const historyResults = await chrome.scripting.executeScript({\n        target: { tabId },\n        func: () => ({\n          canGoBack: window.history.length > 1,\n          url: window.location.href\n        })\n      });\n      \n      const { canGoBack } = historyResults[0].result;\n      \n      if (canGoBack) {\n        // Navigate back if possible using script injection\n        await chrome.scripting.executeScript({\n          target: { tabId },\n          func: () => window.history.back()\n        });\n        \n        // Success, we're done\n        return;\n      }\n      \n      // Can't go back, use fallback approach\n      await handleNavigationFallback(tabId, tab);\n    } catch (err) {\n      console.error(\"Script execution error:\", err);\n      \n      // Fallback to simpler chrome.tabs.goBack API\n      try {\n        await chrome.tabs.goBack(tabId);\n      } catch (backError) {\n        // If that fails too, use final fallback\n        await handleNavigationFallback(tabId, tab);\n      }\n    }\n  } catch (err) {\n    console.error(\"Tab lookup error:\", err);\n    // Tab might no longer exist, nothing to do\n  }\n}\n\n/**\n * Fallback navigation handler when going back isn't possible\n */\nasync function handleNavigationFallback(tabId: number, tab: chrome.tabs.Tab): Promise<void> {\n  try {\n    // Get all tabs in the window\n    const allTabs = await chrome.tabs.query({ windowId: tab.windowId });\n    \n    if (allTabs.length > 1) {\n      // More than one tab, find one to focus\n      const currentIndex = allTabs.findIndex(t => t.id === tabId);\n      const targetIndex = currentIndex > 0 ? currentIndex - 1 : (currentIndex + 1) % allTabs.length;\n      const targetTab = allTabs[targetIndex];\n      \n      // Focus the other tab first\n      if (targetTab.id) {\n        await chrome.tabs.update(targetTab.id, { active: true });\n        \n        // Then remove the current tab\n        setTimeout(() => {\n          chrome.tabs.remove(tabId).catch(e => {\n            console.error(\"Tab removal failed:\", e);\n          });\n        }, 100);\n      }\n    } else {\n      // Last tab, navigate to blank page instead\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    }\n  } catch (e) {\n    console.error(\"Navigation fallback failed:\", e);\n    // Last resort - try basic navigation\n    try {\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    } catch (finalError) {\n      console.error(\"Final fallback failed:\", finalError);\n    }\n  }\n}\n\n/**\n * Show a toast notification in the current tab\n */\nexport async function showToast(tabId: number, message: string, duration = 3000): Promise<void> {\n  try {\n    await chrome.scripting.executeScript({\n      target: { tabId },\n      func: (msg: string, dur: number) => {\n        const toast = document.createElement(\"div\");\n        toast.style.cssText = `\n          position: fixed;\n          bottom: 20px;\n          right: 20px;\n          background-color: rgba(0, 102, 204, 0.9);\n          color: white;\n          padding: 12px 20px;\n          border-radius: 4px;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n          font-family: Arial, sans-serif;\n          z-index: 2147483647;\n          max-width: 300px;\n          transition: opacity 0.3s ease-in-out;\n        `;\n        toast.textContent = msg;\n        document.body.appendChild(toast);\n        \n        // Fade out and remove\n        setTimeout(() => {\n          toast.style.opacity = \"0\";\n          setTimeout(() => toast.remove(), 300);\n        }, dur - 300);\n      },\n      args: [message, duration]\n    });\n  } catch (error) {\n    console.error(\"Error showing toast:\", error);\n  }\n}\n\n/**\n * Clear all parked links without opening them\n */\nexport async function clearParkedLinks(): Promise<void> {\n  await setStorage({ parkedLinks: [] });\n} ","import { pickColorForContext } from \"../lib/pickColor\";\n\nexport async function groupTabByContext(tabId: number, context: string): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  let existingGroup = groups.find((grp) => grp.title === context);\n\n  if (!existingGroup) {\n    // Create new group if none match\n    const newGroupId = await chrome.tabs.group({ tabIds: [tabId] });\n    existingGroup = await chrome.tabGroups.update(newGroupId, {\n      title: context,\n      color: pickColorForContext(context),\n    });\n  } else {\n    // Add to existing group\n    await chrome.tabs.group({ groupId: existingGroup.id, tabIds: [tabId] });\n  }\n}\n\nexport function onTabRemoved(callback: (tabId: number) => void): void {\n  chrome.tabs.onRemoved.addListener(callback);\n}\n\n/** Ungroup every tab in every window */\nexport async function ungroupAllTabs(): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  for (const g of groups) {\n    const tabs = await chrome.tabs.query({ groupId: g.id });\n    if (tabs.length) {\n      await chrome.tabs.ungroup(tabs.map(t => t.id!));\n    }\n  }\n}","import { getStorage, setStorage } from \"./storageApi\";\nimport { FocusStatus, FocusSettings, ContextSwitch } from \"../types/index\";\n\nconst DEFAULT_FOCUS_SETTINGS: FocusSettings = {\n  enabled: true,\n  notificationsEnabled: true,\n  switchThreshold: 5,\n  timeWindowMinutes: 15\n};\n\n/**\n * Get the current focus settings\n */\nexport async function getFocusSettings(): Promise<FocusSettings> {\n  const { focusSettings } = await getStorage([\"focusSettings\"]);\n  return { ...DEFAULT_FOCUS_SETTINGS, ...focusSettings };\n}\n\n/**\n * Update focus settings\n */\nexport async function updateFocusSettings(settings: Partial<FocusSettings>): Promise<void> {\n  const currentSettings = await getFocusSettings();\n  await setStorage({ \n    focusSettings: { ...currentSettings, ...settings } \n  });\n}\n\n/**\n * Get context switches in a time window\n */\nexport async function getContextSwitches(timeWindowMinutes: number = 15): Promise<ContextSwitch[]> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (!contextHistory || contextHistory.length < 2) {\n    return [];\n  }\n  \n  const switches: ContextSwitch[] = [];\n  const now = Date.now();\n  const timeWindow = timeWindowMinutes * 60 * 1000;\n  \n  // Filter history to time window\n  const relevantHistory = contextHistory.filter(\n    entry => (now - entry.timestamp) < timeWindow\n  );\n  \n  // Find context switches\n  for (let i = 1; i < relevantHistory.length; i++) {\n    if (relevantHistory[i].context !== relevantHistory[i-1].context) {\n      switches.push({\n        from: relevantHistory[i-1].context,\n        to: relevantHistory[i].context,\n        timestamp: relevantHistory[i].timestamp,\n        fromUrl: relevantHistory[i-1].url,\n        toUrl: relevantHistory[i].url\n      });\n    }\n  }\n  \n  return switches;\n}\n\n/**\n * Check if focus is lost based on context switching\n */\nexport async function checkFocusStatus(): Promise<FocusStatus> {\n  const settings = await getFocusSettings();\n  const switches = await getContextSwitches(settings.timeWindowMinutes);\n  \n  let currentContext = \"Unknown\";\n  let currentStreak = 1;\n  \n  // Get most recent context and streak\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (contextHistory && contextHistory.length > 0) {\n    currentContext = contextHistory[contextHistory.length - 1].context;\n    \n    // Count consecutive entries with same context\n    let i = contextHistory.length - 1;\n    while (i > 0 && contextHistory[i].context === currentContext) {\n      currentStreak++;\n      i--;\n    }\n  }\n  \n  // Determine if focus is lost\n  const isLostFocus = switches.length >= settings.switchThreshold;\n  \n  return {\n    isLostFocus,\n    contextSwitches: switches,\n    currentStreak,\n    currentContext\n  };\n}\n\n/**\n * Show focus notification\n */\nexport function showFocusNotification(contextSwitches: ContextSwitch[]): void {\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Alert',\n    message: `You've switched contexts ${contextSwitches.length} times recently. Try to maintain focus.`,\n    buttons: [\n      { title: 'View Details' }\n    ]\n  });\n}","/**\n * Declarative Net Request rules for efficient content blocking\n */\nimport { getFocusState } from \"../api/storageApi\";\n\n// Constants\nconst RULE_ID_OFFSET = 100;\nconst MAX_DNR_RULES = 5000;\nconst BLOCKED_PAGE_URL = chrome.runtime.getURL(\"blocked.html\");\n\n/**\n * Apply allowed contexts as declarative blocking rules\n * \n * This function takes the current allowed contexts and creates dynamic DNR rules\n * to block all requests to domains that are categorized outside those contexts.\n */\nexport async function applyAllowedContexts(): Promise<void> {\n  try {\n    // Get the current focus state\n    const focusState = await getFocusState();\n    \n    // If focus is not active, remove all rules\n    if (!focusState.active) {\n      await chrome.declarativeNetRequest.updateDynamicRules({\n        removeRuleIds: await getCurrentRuleIds()\n      });\n      return;\n    }\n    \n    // Get domains classified by context\n    const { domainContextMap } = await chrome.storage.local.get('domainContextMap') as { \n      domainContextMap: Record<string, string> \n    };\n    \n    if (!domainContextMap) {\n      console.warn(\"No domain context map found, cannot create blocking rules\");\n      return;\n    }\n    \n    // Group domains by context\n    const domainsByContext: Record<string, string[]> = {};\n    for (const [domain, context] of Object.entries(domainContextMap)) {\n      if (!domainsByContext[context]) {\n        domainsByContext[context] = [];\n      }\n      domainsByContext[context].push(domain);\n    }\n    \n    // Create rules for each blocked context\n    const rules: chrome.declarativeNetRequest.Rule[] = [];\n    const blockedContexts = getAllKnownContexts().filter(\n      ctx => !focusState.allowedContexts.includes(ctx)\n    );\n    \n    let ruleId = RULE_ID_OFFSET;\n    \n    for (const context of blockedContexts) {\n      const domains = domainsByContext[context] || [];\n      \n      // Skip if no domains in this context\n      if (domains.length === 0) continue;\n      \n      // Add a rule for this context\n      rules.push({\n        id: ruleId++,\n        priority: 1,\n        action: {\n          type: chrome.declarativeNetRequest.RuleActionType.REDIRECT,\n          redirect: { url: BLOCKED_PAGE_URL }\n        },\n        condition: {\n          urlFilter: domains.join('|'),\n          resourceTypes: [chrome.declarativeNetRequest.ResourceType.MAIN_FRAME]\n        }\n      });\n      \n      // DNR has a rule limit, so break if we hit it\n      if (rules.length >= MAX_DNR_RULES) {\n        console.warn(`Hit DNR rule limit of ${MAX_DNR_RULES}`);\n        break;\n      }\n    }\n    \n    // Apply the rules\n    await chrome.declarativeNetRequest.updateDynamicRules({\n      removeRuleIds: await getCurrentRuleIds(),\n      addRules: rules\n    });\n    \n    console.log(`[DNR] Applied ${rules.length} blocking rules for ${blockedContexts.length} contexts`);\n  } catch (error) {\n    console.error(\"Error applying DNR rules:\", error);\n  }\n}\n\n/**\n * Get current active rule IDs\n */\nasync function getCurrentRuleIds(): Promise<number[]> {\n  const rules = await chrome.declarativeNetRequest.getDynamicRules();\n  return rules.map(rule => rule.id);\n}\n\n/**\n * Get all known context categories\n */\nfunction getAllKnownContexts(): string[] {\n  return [\n    \"Work\", \"Development\", \"Research\", \"Learning\", \n    \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n  ];\n} ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(545);\n"],"names":["getStorage","keys","Promise","resolve","reject","chrome","storage","local","get","result","runtime","lastError","setStorage","data","set","async","getFocusState","focusState","active","allowedContexts","context","url","confidence","contextHistory","newHistory","push","timestamp","Date","now","length","shift","partialState","currentState","focusWindowId","launchFocusWindow","undefined","windows","error","id","create","type","state","tabs","query","windowId","update","getURL","console","remove","tabId","move","index","blockClearTimer","recentlyBlocked","allowed","durationMin","safeAllowed","Array","isArray","endTime","setFocusState","blockedCategories","filter","ctx","includes","openSidePanel","focusSettings","focusWindowEnabled","action","setBadgeText","text","setBadgeBackgroundColor","color","notifications","iconUrl","title","message","priority","saveWorkspaceName","groups","tabGroups","workspaceGroups","all","map","grp","groupId","tabUrls","t","savedWorkspaces","newWorkspaceEntry","name","updatedWorkspaces","closeSidePanel","closeFocusWindow","ungroupAllTabs","clearTimeout","releaseParkedLinks","log","setTimeout","Math","max","workspace","find","ws","tabIds","createdTab","newGroupId","group","currentWindow","getCurrent","sidePanel","open","panels","getAll","panel","close","path","setOptions","enabled","tabContextMap","BLOCKED_PAGE_URL","updateBadge","getContextData","contexts","training","falsePositives","truePositives","saveContextData","onMessage","addListener","request","sender","sendResponse","tab","secondaryContexts","autoGroupEnabled","groupTabByContext","handleContextUpdate","catch","err","focusEngine","start","applyAllowedContexts","end","toggleFocusMode","durationMinutes","payload","then","success","getTimeLeft","seconds","restoreWorkspace","checkFocusStatus","sendMessage","resp","saveForLater","String","actualContext","predictedContext","isFalsePositive","contextData","weights","forEach","fp","tp","updateContextWeights","goBackOrClose","e","Error","onTabRemoved","removedTabId","onChanged","changes","onInstalled","details","reason","extensionEnabled","firstRunComplete","focusSessionActive","knownContexts","focusSessionEndTime","toLocaleTimeString","alarms","periodInMinutes","onAlarm","isActive","checkFocusSessionStatus","focusStatus","isLostFocus","activeTab","startsWith","contextSwitches","lastSwitch","from","to","requireInteraction","sendDriftWarning","initExtension","getParkedLinks","parkedLinks","handleNavigationFallback","allTabs","currentIndex","findIndex","targetTab","finalError","some","link","newLink","openedTabIds","groupError","historyResults","scripting","executeScript","target","func","canGoBack","window","history","location","href","back","goBack","backError","duration","msg","dur","toast","document","createElement","style","cssText","textContent","body","appendChild","opacity","args","existingGroup","pickColorForContext","callback","onRemoved","g","ungroup","DEFAULT_FOCUS_SETTINGS","notificationsEnabled","switchThreshold","timeWindowMinutes","getFocusSettings","getContextSwitches","switches","timeWindow","relevantHistory","entry","i","fromUrl","toUrl","settings","currentSettings","currentContext","currentStreak","buttons","getCurrentRuleIds","declarativeNetRequest","getDynamicRules","rule","updateDynamicRules","removeRuleIds","domainContextMap","warn","domainsByContext","domain","Object","entries","rules","blockedContexts","ruleId","domains","RuleActionType","REDIRECT","redirect","condition","urlFilter","join","resourceTypes","ResourceType","MAIN_FRAME","addRules","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}