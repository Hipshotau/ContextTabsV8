{"version":3,"file":"background.js","mappings":"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","sources":["webpack://context-focus/./src/api/storageApi.ts","webpack://context-focus/./src/lib/windows/focusWindow.ts","webpack://context-focus/./src/lib/pickColor.ts","webpack://context-focus/./src/lib/focusEngine.ts","webpack://context-focus/./src/lib/panels/sidePanelManager.ts","webpack://context-focus/./src/lib/contextEngine/urlAnalyzer.ts","webpack://context-focus/./src/background/index.ts","webpack://context-focus/./src/api/parkedLinksApi.ts","webpack://context-focus/./src/api/tabsApi.ts","webpack://context-focus/./src/api/focusApi.ts","webpack://context-focus/./src/background/blockingRules.ts","webpack://context-focus/webpack/bootstrap","webpack://context-focus/webpack/startup"],"sourcesContent":["import { FocusSettings, StorageData as TypesStorageData, FocusState } from \"../types/index\";\n\n// Re-export the StorageData interface from types/index.d.ts\nexport type StorageData = TypesStorageData;\n\n/**\n * Get an object containing the requested keys.\n */\nexport function getStorage<T extends keyof StorageData>(\n  keys: T[]\n): Promise<Pick<StorageData, T>> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.get(keys, (result) => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve(result as Pick<StorageData, T>);\n    });\n  });\n}\n\n/**\n * Set or update the given keys in storage.\n */\nexport function setStorage(data: Partial<StorageData>): Promise<void> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.set(data, () => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * Add a context entry to history\n */\nexport async function addContextToHistory(\n  context: string,\n  url: string,\n  confidence: number\n): Promise<void> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  const newHistory = contextHistory || [];\n  \n  // Add new entry\n  newHistory.push({\n    context,\n    url,\n    timestamp: Date.now(),\n    confidence\n  });\n  \n  // Limit history size\n  if (newHistory.length > 100) {\n    newHistory.shift();\n  }\n  \n  await setStorage({ contextHistory: newHistory });\n}\n\n/**\n * Get the current focus state\n */\nexport async function getFocusState(): Promise<FocusState> {\n  const { focusState } = await getStorage([\"focusState\"]);\n  \n  // Default state if none exists\n  const defaultState: FocusState = {\n    active: false,\n    allowedContexts: []\n  };\n  \n  return { ...defaultState, ...focusState };\n}\n\n/**\n * Update the focus state\n */\nexport async function setFocusState(partialState: Partial<FocusState>): Promise<void> {\n  const currentState = await getFocusState();\n  await setStorage({ \n    focusState: { ...currentState, ...partialState }\n  });\n}","let focusWindowId: number | undefined;\n\n/**\n * Create a dedicated window for the focus session\n * This creates a new window that can be populated with productive tabs\n */\nexport async function launchFocusWindow(): Promise<number | undefined> {\n  try {\n    // Check if focus window already exists\n    if (focusWindowId !== undefined) {\n      try {\n        // Try to get window to verify it still exists\n        await chrome.windows.get(focusWindowId);\n        return focusWindowId; // Window already exists\n      } catch (error) {\n        // Window doesn't exist anymore, reset the ID\n        focusWindowId = undefined;\n      }\n    }\n\n    // Create a new window\n    const { id } = await chrome.windows.create({\n      url: \"about:blank\",\n      type: \"normal\",\n      state: \"maximized\"\n    });\n    \n    focusWindowId = id;\n    \n    // Create a welcoming tab\n    if (id) {\n      const tabs = await chrome.tabs.query({ windowId: id });\n      \n      // If there's at least one tab (the default about:blank), update it\n      if (tabs.length > 0 && tabs[0].id) {\n        await chrome.tabs.update(tabs[0].id, { \n          url: chrome.runtime.getURL(\"blocked.html\") + \"?mode=welcome\" \n        });\n      }\n    }\n    \n    return focusWindowId;\n  } catch (error) {\n    console.error(\"Error launching focus window:\", error);\n    return undefined;\n  }\n}\n\n/**\n * Close the dedicated focus window\n */\nexport async function closeFocusWindow(): Promise<void> {\n  if (focusWindowId === undefined) return;\n  \n  try {\n    await chrome.windows.remove(focusWindowId);\n    focusWindowId = undefined;\n  } catch (error) {\n    console.error(\"Error closing focus window:\", error);\n    // Reset the ID even if there was an error\n    focusWindowId = undefined;\n  }\n}\n\n/**\n * Check if the focus window is active\n */\nexport function getFocusWindowId(): number | undefined {\n  return focusWindowId;\n}\n\n/**\n * Move a tab to the focus window\n */\nexport async function moveTabToFocusWindow(tabId: number): Promise<boolean> {\n  if (focusWindowId === undefined) {\n    const windowId = await launchFocusWindow();\n    if (windowId === undefined) return false;\n  }\n  \n  try {\n    await chrome.tabs.move(tabId, { windowId: focusWindowId!, index: -1 });\n    return true;\n  } catch (error) {\n    console.error(\"Error moving tab to focus window:\", error);\n    return false;\n  }\n} ","export function pickColorForContext(context: string): chrome.tabGroups.ColorEnum {\n  switch (context) {\n    case \"Work\":\n      return \"yellow\";\n    case \"Learning\":\n      return \"blue\";\n    case \"Entertainment\":\n      return \"green\";\n    case \"News\":\n      return \"red\";\n    case \"Shopping\":\n      return \"purple\";\n    case \"Social\":\n      return \"cyan\";\n    case \"Research\":\n      return \"pink\";\n    case \"Development\":\n      return \"orange\";\n    default:\n      return \"grey\";  // Chrome uses \"grey\" (British spelling) not \"gray\"\n  }\n}","/**\n * Focus Engine - Core logic for the Focus feature\n * \n * This module implements the state machine for focus mode, following the principle\n * of \"block by exclusion\" - where user picks ALLOWED contexts and everything else is blocked.\n */\n\nimport { getFocusState, setFocusState, getStorage, setStorage } from \"../api/storageApi\";\nimport { FocusState } from \"../types/index\";\nimport { openSidePanel, closeSidePanel } from \"../lib/panels/sidePanelManager\";\nimport { launchFocusWindow, closeFocusWindow } from \"../lib/windows/focusWindow\";\nimport { releaseParkedLinks } from \"../api/parkedLinksApi\";\nimport { ungroupAllTabs } from \"../api/tabsApi\";\n\n// State for tracking if a navigation was blocked recently (for badge alert)\nlet recentlyBlocked = false;\nlet blockClearTimer: NodeJS.Timeout | undefined;\n\n/**\n * Start a focus session\n * \n * @param allowed - Array of context categories that are allowed during focus\n * @param durationMin - Optional duration in minutes after which focus will automatically end\n */\nexport async function start(allowed: string[], durationMin?: number): Promise<void> {\n  // Safety check for allowed contexts\n  const safeAllowed = Array.isArray(allowed) ? allowed : [];\n  \n  // Calculate end time if duration is provided\n  const endTime = durationMin ? Date.now() + durationMin * 60 * 1000 : undefined;\n  \n  // Save focus state\n  await setFocusState({\n    active: true,\n    allowedContexts: safeAllowed,\n    endTime\n  });\n  \n  // Store blockedCategories for backward compatibility\n  const knownContexts = [\n    \"Work\", \"Development\", \"Research\", \"Learning\", \n    \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n  ];\n  const blockedCategories = knownContexts.filter(ctx => !safeAllowed.includes(ctx));\n  await setStorage({ blockedCategories });\n  \n  // Open the side panel for persistent timer display\n  await openSidePanel();\n  \n  // Check if focus window is enabled and launch if needed\n  const storage = await getStorage([\"focusSettings\"]);\n  const focusWindowEnabled = storage.focusSettings?.focusWindowEnabled || false;\n  if (focusWindowEnabled) {\n    await launchFocusWindow();\n  }\n  \n  // Set badge to show focus is active\n  chrome.action.setBadgeText({ text: \"•\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n  \n  // Show notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Started',\n    message: durationMin ? \n      `Focus session started for ${durationMin} minutes. Stay focused!` :\n      'Focus session started. Stay focused!',\n    priority: 2\n  });\n}\n\n/**\n * End a focus session\n * @param saveWorkspaceName - Optional workspace name to save current tab groups\n */\nexport async function end(saveWorkspaceName?: string): Promise<void> {\n  // If user wants to save workspace, store it\n  if (saveWorkspaceName) {\n    try {\n      // Get all tab groups\n      const groups = await chrome.tabGroups.query({});\n      // For each group, gather tab URLs\n      const workspaceGroups = await Promise.all(\n        groups.map(async (grp) => {\n          const tabs = await chrome.tabs.query({ groupId: grp.id });\n          return {\n            groupId: grp.id,\n            title: grp.title || \"\",\n            color: grp.color,\n            tabUrls: tabs.map(t => t.url || \"\")\n          };\n        })\n      );\n\n      // Store in savedWorkspaces\n      const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n      const newWorkspaceEntry = {\n        name: saveWorkspaceName,\n        tabGroups: workspaceGroups,\n        timestamp: Date.now()\n      };\n\n      const updatedWorkspaces = Array.isArray(savedWorkspaces) \n        ? [...savedWorkspaces, newWorkspaceEntry]\n        : [newWorkspaceEntry];\n\n      await setStorage({ savedWorkspaces: updatedWorkspaces });\n    } catch (error) {\n      console.error(\"Error saving workspace:\", error);\n    }\n  }\n  \n  // Clear focus state\n  await setFocusState({\n    active: false,\n    endTime: undefined\n  });\n  \n  // Close UI components\n  await closeSidePanel();\n  await closeFocusWindow();\n  await ungroupAllTabs();\n  \n  // Clear badge\n  chrome.action.setBadgeText({ text: \"\" });\n  \n  // Reset block indicator\n  recentlyBlocked = false;\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n    blockClearTimer = undefined;\n  }\n  \n  // Show notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Ended',\n    message: 'Your focus session has ended. Great job!',\n    priority: 2\n  });\n  \n  // Release any links that were parked during the session\n  await releaseParkedLinks();\n}\n\n/**\n * Check if a context should be blocked\n * \n * @param context - The context category to check\n * @returns true if the context should be blocked, false otherwise\n */\nexport async function isBlocked(context: string): Promise<boolean> {\n  const focusState = await getFocusState();\n  \n  // If focus is not active, nothing is blocked\n  if (!focusState.active) {\n    return false;\n  }\n  \n  // Safety check: ensure allowedContexts is an array before using includes\n  if (!Array.isArray(focusState.allowedContexts)) {\n    console.error(\"[FocusEngine] allowedContexts is not an array:\", focusState.allowedContexts);\n    return false; // Fail open rather than blocking everything\n  }\n  \n  // Add logging to help debug\n  console.log(\"[FocusEngine] allowed:\", focusState.allowedContexts, \"context:\", context);\n  \n  // If context is in allowed list, it's not blocked\n  if (focusState.allowedContexts.includes(context)) {\n    return false;\n  }\n  \n  // Context is not in allowed list, so it's blocked\n  // Update the \"recently blocked\" state for badge\n  recentlyBlocked = true;\n  \n  // Show red \"!\" badge\n  chrome.action.setBadgeText({ text: \"!\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red\n  \n  // Clear the blocked indicator after 30 seconds\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n  }\n  \n  blockClearTimer = setTimeout(() => {\n    if (recentlyBlocked) {\n      recentlyBlocked = false;\n      // Restore the normal focus badge\n      chrome.action.setBadgeText({ text: \"•\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n    }\n  }, 30000);\n  \n  return true;\n}\n\n/**\n * Check if a focus session is currently active\n * \n * @returns true if a focus session is active, false otherwise\n */\nexport async function isActive(): Promise<boolean> {\n  const focusState = await getFocusState();\n  return focusState.active;\n}\n\n/**\n * Get the time left in the current focus session in seconds\n * \n * @returns Seconds left in the focus session, or -1 if no timer (unlimited session)\n */\nexport async function getTimeLeft(): Promise<number> {\n  const { active, endTime } = await getFocusState();\n  if (!active) return 0; // Not active, no time\n  if (!endTime) return -1; // -1 = unlimited/indefinite session\n  return Math.max(0, endTime - Date.now()) / 1000; // seconds\n}\n\n/**\n * Restore a saved workspace by name. \n * Re-open tabs and re-create groups (approximation).\n */\nexport async function restoreWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const workspace = savedWorkspaces.find(ws => ws.name === name);\n  if (!workspace) return;\n\n  // For each group, re-create tabs\n  for (const grp of workspace.tabGroups) {\n    // Open each tab\n    const tabIds = [];\n    for (const url of grp.tabUrls) {\n      const createdTab = await chrome.tabs.create({ url, active: false });\n      tabIds.push(createdTab.id as number);\n    }\n    // Create or update tab group\n    if (tabIds.length > 0) {\n      const newGroupId = await chrome.tabs.group({ tabIds });\n      await chrome.tabGroups.update(newGroupId, {\n        title: grp.title || \"\",\n        color: grp.color\n      });\n    }\n  }\n}\n\n/**\n * Save current window's tab groups (workspace).\n * This can be called at the end of a Focus Session or on demand.\n */\nexport async function saveCurrentWorkspace(name: string): Promise<void> {\n  // Get all tab groups\n  const groups = await chrome.tabGroups.query({});\n  // For each group, gather tab URLs\n  const workspaceGroups = await Promise.all(\n    groups.map(async (grp) => {\n      const tabs = await chrome.tabs.query({ groupId: grp.id });\n      return {\n        groupId: grp.id,\n        title: grp.title || \"\",\n        color: grp.color,\n        tabUrls: tabs.map(t => t.url || \"\")\n      };\n    })\n  );\n\n  // Store in savedWorkspaces\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  const newWorkspaceEntry = {\n    name,\n    tabGroups: workspaceGroups,\n    timestamp: Date.now()\n  };\n\n  const updatedWorkspaces = Array.isArray(savedWorkspaces) \n    ? [...savedWorkspaces, newWorkspaceEntry]\n    : [newWorkspaceEntry];\n\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n}\n\n/**\n * Clean up old workspace entries if needed, or remove a workspace by name, etc.\n */\nexport async function removeWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const updatedWorkspaces = savedWorkspaces.filter(ws => ws.name !== name);\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n} ","/**\n * Open the side panel in the current window\n */\nexport async function openSidePanel(): Promise<void> {\n  try {\n    const currentWindow = await chrome.windows.getCurrent();\n    await chrome.sidePanel.open({ windowId: currentWindow.id });\n    console.log(\"Side panel opened successfully\");\n  } catch (error) {\n    console.error(\"Error opening side panel:\", error);\n  }\n}\n\n/**\n * Close the side panel in all windows\n */\nexport async function closeSidePanel(): Promise<void> {\n  try {\n    const panels = await chrome.sidePanel.getAll();\n    await Promise.all(panels.map((panel: chrome.sidePanel.PanelInfo) => \n      chrome.sidePanel.close({ windowId: panel.windowId })\n    ));\n    console.log(\"Side panels closed successfully\");\n  } catch (error) {\n    console.error(\"Error closing side panels:\", error);\n  }\n}\n\n/**\n * Set the side panel properties\n */\nexport async function setSidePanelProperties(path: string, title: string): Promise<void> {\n  try {\n    await chrome.sidePanel.setOptions({\n      path,\n      enabled: true\n    });\n    console.log(\"Side panel properties updated\");\n  } catch (error) {\n    console.error(\"Error setting side panel properties:\", error);\n  }\n} ","// Known domain categories\nexport const DOMAIN_CATEGORIES: Record<string, string> = {\n  // Work/Productivity\n  \"docs.google.com\": \"Work\",\n  \"sheets.google.com\": \"Work\",\n  \"slides.google.com\": \"Work\",\n  \"drive.google.com\": \"Work\",\n  \"office.com\": \"Work\",\n  \"microsoft365.com\": \"Work\",\n  \"linkedin.com\": \"Work\",\n  \"slack.com\": \"Work\",\n  \"teams.microsoft.com\": \"Work\",\n  \"asana.com\": \"Work\",\n  \"trello.com\": \"Work\",\n  \"notion.so\": \"Work\",\n  \"monday.com\": \"Work\",\n  \"atlassian.com\": \"Work\",\n  \"jira.com\": \"Work\",\n  \"basecamp.com\": \"Work\",\n  \"zoom.us\": \"Work\",\n  \n  // Learning\n  \"coursera.org\": \"Learning\",\n  \"udemy.com\": \"Learning\",\n  \"edx.org\": \"Learning\",\n  \"khanacademy.org\": \"Learning\",\n  \"duolingo.com\": \"Learning\",\n  \"canvas.instructure.com\": \"Learning\",\n  \"blackboard.com\": \"Learning\",\n  \"quizlet.com\": \"Learning\",\n  \"chegg.com\": \"Learning\",\n  \"brilliant.org\": \"Learning\",\n  \"codecademy.com\": \"Learning\",\n  \"freecodecamp.org\": \"Learning\",\n  \"lynda.com\": \"Learning\",\n  \"skillshare.com\": \"Learning\",\n  \"pluralsight.com\": \"Learning\",\n  \n  // Entertainment\n  \"netflix.com\": \"Entertainment\",\n  \"hulu.com\": \"Entertainment\",\n  \"disneyplus.com\": \"Entertainment\",\n  \"hbomax.com\": \"Entertainment\",\n  \"youtube.com\": \"Entertainment\",\n  \"twitch.tv\": \"Entertainment\",\n  \"spotify.com\": \"Entertainment\",\n  \"pandora.com\": \"Entertainment\",\n  \"tidal.com\": \"Entertainment\",\n  \"soundcloud.com\": \"Entertainment\",\n  \"steam.com\": \"Entertainment\",\n  \"epicgames.com\": \"Entertainment\",\n  \"ign.com\": \"Entertainment\",\n  \"imdb.com\": \"Entertainment\",\n  \"rottentomatoes.com\": \"Entertainment\",\n  \n  // News\n  \"cnn.com\": \"News\",\n  \"bbc.com\": \"News\",\n  \"nytimes.com\": \"News\",\n  \"washingtonpost.com\": \"News\",\n  \"reuters.com\": \"News\",\n  \"apnews.com\": \"News\",\n  \"foxnews.com\": \"News\",\n  \"nbcnews.com\": \"News\",\n  \"abcnews.go.com\": \"News\",\n  \"cbsnews.com\": \"News\",\n  \"politico.com\": \"News\",\n  \"economist.com\": \"News\",\n  \"wsj.com\": \"News\",\n  \"bloomberg.com\": \"News\",\n  \"theguardian.com\": \"News\",\n  \n  // Development\n  \"github.com\": \"Development\",\n  \"gitlab.com\": \"Development\",\n  \"bitbucket.org\": \"Development\",\n  \"stackoverflow.com\": \"Development\",\n  \"developer.mozilla.org\": \"Development\",\n  \"w3schools.com\": \"Development\",\n  \"codepen.io\": \"Development\",\n  \"replit.com\": \"Development\",\n  \"codesandbox.io\": \"Development\",\n  \"jsfiddle.net\": \"Development\",\n  \"npmjs.com\": \"Development\",\n  \"pypi.org\": \"Development\",\n  \"docker.com\": \"Development\",\n  \"kubernetes.io\": \"Development\",\n  \"digitalocean.com\": \"Development\",\n  \n  // Shopping\n  \"amazon.com\": \"Shopping\",\n  \"ebay.com\": \"Shopping\",\n  \"walmart.com\": \"Shopping\",\n  \"target.com\": \"Shopping\",\n  \"bestbuy.com\": \"Shopping\",\n  \"etsy.com\": \"Shopping\",\n  \"aliexpress.com\": \"Shopping\",\n  \"wayfair.com\": \"Shopping\",\n  \"costco.com\": \"Shopping\",\n  \"newegg.com\": \"Shopping\",\n  \"homedepot.com\": \"Shopping\",\n  \"lowes.com\": \"Shopping\",\n  \"macys.com\": \"Shopping\",\n  \"nordstrom.com\": \"Shopping\",\n  \"zappos.com\": \"Shopping\",\n  \n  // Social\n  \"facebook.com\": \"Social\",\n  \"twitter.com\": \"Social\",\n  \"instagram.com\": \"Social\",\n  \"reddit.com\": \"Social\",\n  \"pinterest.com\": \"Social\",\n  \"tumblr.com\": \"Social\",\n  \"tiktok.com\": \"Social\",\n  \"snapchat.com\": \"Social\",\n  \"discord.com\": \"Social\",\n  \"messenger.com\": \"Social\",\n  \"telegram.org\": \"Social\",\n  \"whatsapp.com\": \"Social\",\n  \"signal.org\": \"Social\",\n  \"medium.com\": \"Social\",\n  \"quora.com\": \"Social\",\n  \n  // Research\n  \"scholar.google.com\": \"Research\",\n  \"pubmed.ncbi.nlm.nih.gov\": \"Research\",\n  \"researchgate.net\": \"Research\",\n  \"academia.edu\": \"Research\",\n  \"jstor.org\": \"Research\",\n  \"springer.com\": \"Research\",\n  \"sciencedirect.com\": \"Research\",\n  \"ieee.org\": \"Research\",\n  \"ncbi.nlm.nih.gov\": \"Research\",\n  \"arxiv.org\": \"Research\",\n  \"sciencemag.org\": \"Research\",\n  \"nature.com\": \"Research\",\n  \"webofknowledge.com\": \"Research\",\n  \"scopus.com\": \"Research\",\n  \"mendeley.com\": \"Research\"\n};\n\n/**\n * Extract domain from URL\n */\nexport function extractDomain(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.hostname;\n  } catch (error) {\n    console.error(\"Error extracting domain:\", error);\n    return \"\";\n  }\n}\n\n/**\n * Get domain category from predefined list\n */\nexport function getDomainCategory(domain: string): string | undefined {\n  // Try exact match\n  if (DOMAIN_CATEGORIES[domain]) {\n    return DOMAIN_CATEGORIES[domain];\n  }\n  \n  // Try with 'www.' prefix removed\n  if (domain.startsWith('www.')) {\n    const withoutWww = domain.substring(4);\n    if (DOMAIN_CATEGORIES[withoutWww]) {\n      return DOMAIN_CATEGORIES[withoutWww];\n    }\n  }\n  \n  // Try parent domain\n  const parts = domain.split('.');\n  if (parts.length > 2) {\n    const parentDomain = parts.slice(parts.length - 2).join('.');\n    return DOMAIN_CATEGORIES[parentDomain];\n  }\n  \n  return undefined;\n}\n\n/**\n * Extract path keywords from URL\n */\nexport function extractPathKeywords(url: string): string[] {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.pathname\n      .split('/')\n      .filter(Boolean)\n      .flatMap(segment => \n        segment\n          .split(/[-_]/)\n          .filter(word => word.length > 2)\n      );\n  } catch (error) {\n    console.error(\"Error extracting path keywords:\", error);\n    return [];\n  }\n}\n\n/**\n * Analyze URL for context clues\n */\nexport function analyzeUrl(url: string): Record<string, number> {\n  const domain = extractDomain(url);\n  const domainCategory = getDomainCategory(domain);\n  const pathKeywords = extractPathKeywords(url);\n  \n  const scores: Record<string, number> = {};\n  \n  // Set base score from domain\n  if (domainCategory) {\n    scores[domainCategory] = 0.8;\n  }\n  \n  // Add scores from path keywords (could be enhanced with TF-IDF against keywords)\n  // This is a simplified implementation\n  \n  return scores;\n}","import { groupTabByContext, onTabRemoved, ungroupAllTabs } from \"../api/tabsApi\";\nimport { getStorage, setStorage, getFocusState, setFocusState } from \"../api/storageApi\";\nimport { checkFocusStatus, showFocusNotification } from \"../api/focusApi\";\nimport { classifyPageContext } from \"../lib/contextEngine\";\nimport { extractDomain, DOMAIN_CATEGORIES } from \"../lib/contextEngine/urlAnalyzer\";\nimport { saveForLater, releaseParkedLinks, goBackOrClose } from \"../api/parkedLinksApi\";\nimport * as focusEngine from \"../lib/focusEngine\";\nimport { applyAllowedContexts } from \"./blockingRules\";\n\nconst tabContextMap: Record<number, string> = {};\nconst BLOCKED_PAGE_URL = chrome.runtime.getURL(\"blocked.html\");\n// Track tabs that just came from the blocked page to prevent redirect loops\nconst recentlyUnblockedTabs = new Set<number>();\n\n/**\n * Initialize the extension with proper default settings\n */\nasync function initExtension(): Promise<void> {\n  // Always enable the extension\n  await setStorage({ extensionEnabled: true });\n  \n  console.log(\"[Background] Extension enabled.\");\n  \n  // Pre-seed domain context map with known categories\n  await chrome.storage.local.set({ domainContextMap: DOMAIN_CATEGORIES });\n  \n  // Check for active sessions - now using the new focusState\n  const focusState = await getFocusState();\n  if (focusState.active) {\n    console.log(\"[Background] Focus session was active at shutdown, verifying...\");\n    // Verify session is still valid (not expired)\n    if (!focusState.endTime || focusState.endTime <= Date.now()) {\n      console.log(\"[Background] Focus session expired during shutdown, cleaning up\");\n      await setFocusState({ active: false, endTime: undefined });\n    } else {\n      console.log(`[Background] Focus session continues until ${new Date(focusState.endTime).toLocaleTimeString()}`);\n      \n      // Apply blocking rules for active focus session\n      await applyAllowedContexts();\n    }\n  } else {\n    // Apply blocking rules even if no active session to create initial rules\n    await applyAllowedContexts();\n  }\n  \n  // Set up periodic checks\n  setupPeriodicChecks();\n}\n\n/**\n * Set up all periodic checks needed for the extension\n */\nfunction setupPeriodicChecks() {\n  // Set up alarms for periodic checks - minimum 1 minute for MV3\n  chrome.alarms.create('focusTick', { periodInMinutes: 1 });     // 60s - check session status\n  chrome.alarms.create('focusDrift', { periodInMinutes: 2 });    // 120s - check drift (less urgent)\n  \n  // Handle alarms\n  chrome.alarms.onAlarm.addListener(async ({ name }) => {\n    try {\n      if (name === 'focusTick') {\n        await checkFocusSessionStatus();\n      } else if (name === 'focusDrift') {\n        const isSessionActive = await focusEngine.isActive();\n        if (isSessionActive) {\n          const focusStatus = await checkFocusStatus();\n          if (focusStatus.isLostFocus) {\n            // Immediately send a drift warning if focus is lost\n            await sendDriftWarning(focusStatus);\n          }\n        }\n      }\n      // Update badge for all alarm types\n      await updateBadge();\n    } catch (err) {\n      console.error(`Error in alarm handler (${name}):`, err);\n    }\n  });\n}\n\n/**\n * Handle messages from content scripts and the UI\n */\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.type === \"CONTEXT_UPDATE\" || request.type === \"CONTEXT_DETECTED\") {\n    const context = request.context as string;\n    const tabId = sender.tab?.id;\n    \n    if (tabId != null) {\n      // Check if context has changed\n      const previousContext = tabContextMap[tabId];\n      if (previousContext !== context) {\n        // Notify focus mode about context change\n        // handleContextChange(context);\n      }\n      \n      tabContextMap[tabId] = context;\n      \n      // Store additional context data if available\n      const contextData = {\n        context,\n        confidence: request.confidence,\n        secondaryContexts: request.secondaryContexts,\n        url: request.url\n      };\n      \n      // Save context data to storage for URL blocking functionality\n      chrome.storage.local.set({\n        [request.url]: { context: request.context, confidence: request.confidence }\n      });\n      \n      // Handle the context update\n      handleContextUpdate(tabId, context, contextData).catch((err) => console.error(err));\n    }\n    \n    return false; // No response needed\n  } \n  else if (request.type === \"FOCUS_TOGGLE\") {\n    toggleFocusMode(request.enabled).catch((err) => console.error(err));\n    return false; // No response needed\n  }\n  else if (request.type === \"START_FOCUS_SESSION\") {\n    const { durationMinutes, allowedContexts } = request.payload || {};\n    \n    // Use allowedContexts directly if provided, otherwise fallback to blockedCategories\n    if (allowedContexts) {\n      focusEngine.start(allowedContexts, durationMinutes)\n        .then(() => sendResponse({ success: true }))\n        .catch((err) => {\n          console.error(err);\n          sendResponse({ success: false, error: err.message });\n        });\n    } else {\n      // Legacy support: convert blockedCategories to allowedContexts\n      const { blockedCategories } = request.payload || {};\n      const KNOWN_CONTEXTS = [\n        \"Work\", \"Development\", \"Research\", \"Learning\",\n        \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n      ];\n      const allowedContexts = KNOWN_CONTEXTS.filter(\n        ctx => !blockedCategories?.includes(ctx)\n      );\n      \n      focusEngine.start(allowedContexts, durationMinutes)\n        .then(() => sendResponse({ success: true }))\n        .catch((err) => {\n          console.error(err);\n          sendResponse({ success: false, error: err.message });\n        });\n    }\n    return true; // Indicates async response\n  }\n  else if (request.type === \"END_FOCUS_SESSION\") {\n    const { saveWorkspaceName } = request.payload || {};\n    focusEngine.end(saveWorkspaceName)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(\"Error ending focus session:\", err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"GET_FOCUS_TIME_LEFT\") {\n    focusEngine.getTimeLeft()\n      .then(seconds => {\n        sendResponse({ seconds });\n      })\n      .catch(error => {\n        console.error(\"Error getting focus time left:\", error);\n        sendResponse({ seconds: 0 });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"OVERRIDE_BLOCK\") {\n    // Handle override request with more specific guidance\n    (async () => {\n      try {\n        // Get the tab that sent the request\n        const tabId = sender.tab?.id;\n        if (tabId) {\n          // Add this tab to the temporarily unblocked list\n          recentlyUnblockedTabs.add(tabId);\n          \n          // Remove from allowlist after 5 seconds\n          setTimeout(() => {\n            recentlyUnblockedTabs.delete(tabId);\n          }, 5000);\n          \n          // Return success\n          sendResponse({ success: true });\n        } else {\n          sendResponse({ success: true });\n        }\n      } catch (error) {\n        console.error(\"Error handling override:\", error);\n        sendResponse({ success: true }); // Still succeed to avoid blocking user\n      }\n    })();\n    return true;\n  }\n  else if (request.type === \"RESTORE_WORKSPACE\") {\n    const { name } = request.payload || {};\n    focusEngine.restoreWorkspace(name)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Indicates async response\n  }\n  else if (request.type === \"CHECK_FOCUS_STATUS\") {\n    checkFocusStatus()\n      .then(result => sendResponse(result))\n      .catch(error => {\n        console.error(\"Error checking focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"CONTENT_SCRIPT_READY\") {\n    // Content script is ready to receive messages\n    const tabId = sender.tab?.id;\n    // if (tabId && activeTimer && activeTimer.active && activeTimer.endTime > Date.now()) {\n    //   console.log(`Tab ${tabId} is ready, sending active timer`);\n    //   // Send the timer right away\n    //   chrome.tabs.sendMessage(tabId, {\n    //     type: \"RESTORE_FOCUS_TIMER\",\n    //     timerState: activeTimer\n    //   }).catch(err => {\n    //     console.log('Tab not fully ready, will retry');\n    //     // Try again after a short delay\n    //     setTimeout(() => {\n    //       chrome.tabs.sendMessage(tabId, {\n    //         type: 'RESTORE_FOCUS_TIMER',\n    //         timerState: activeTimer\n    //       }).catch(err => console.error('Failed to restore timer after content script ready retry:', err));\n    //     }, 500);\n    //   });\n    // }\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"TIMER_EXPIRED\") {\n    // Handle timer expiration from the side panel\n    // endFocusTimer();\n    // Show a drift warning on the current page\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      if (tabs[0] && tabs[0].id) {\n        chrome.tabs.sendMessage(tabs[0].id, {\n          type: \"DRIFT_WARNING\",\n          message: \"Time's up! Return to your primary task now.\"\n        }, (resp) => {\n          if (chrome.runtime.lastError || resp === undefined) {\n            // Nobody listened - fall back to the blocked page\n            chrome.tabs.update(tabs[0].id!, {url: BLOCKED_PAGE_URL});\n          }\n        });\n      }\n    });\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"PARK_LINK\") {\n    const { url, context, title } = request;\n    \n    // Handle the parked link asynchronously\n    (async () => {\n      try {\n        await saveForLater(url, context, title);\n        console.log(`[Parked Links] Saved for later: ${title || url} (${context})`);\n      } catch (error) {\n        console.error(\"Error parking link:\", error);\n      }\n    })();\n    \n    return false; // No response needed\n  }\n  else if (request.type === \"RELEASE_PARKED_LINKS\") {\n    // Handle the release of parked links asynchronously\n    (async () => {\n      try {\n        await releaseParkedLinks();\n        sendResponse({ success: true });\n      } catch (error) {\n        console.error(\"Error releasing parked links:\", error);\n        sendResponse({ success: false, error: String(error) });\n      }\n    })();\n    \n    return true; // Indicates async response\n  }\n  else if (request.type === \"TRAIN_CONTEXT\") {\n    (async () => {\n      const { url, title, actualContext, predictedContext, isFalsePositive } = request;\n      \n      // Get or create context data for this URL\n      const contextData = await getContextData(url);\n      \n      // Update training data\n      if (!contextData.training) {\n        contextData.training = {\n          falsePositives: [],\n          truePositives: []\n        };\n      }\n      \n      if (isFalsePositive) {\n        contextData.training.falsePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      } else {\n        contextData.training.truePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      }\n      \n      // Save updated context data\n      await saveContextData(url, contextData);\n      \n      // Recalculate context weights based on training data\n      await updateContextWeights(url);\n      \n      sendResponse({ success: true });\n    })();\n    return true; // Required for async response\n  }\n  else if (request.type === \"STAY_FOCUSED_ACTION\") {\n    (async () => {\n      const { url, context, title } = request.payload;\n      try {\n        await saveForLater(url, context, title);\n        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (tab?.id) await goBackOrClose(tab.id);\n        sendResponse({ success: true });\n      } catch (e: unknown) {\n        console.error(\"Stay‑focused flow failed:\", e);\n        sendResponse({ \n          success: false, \n          error: e instanceof Error ? e.message : String(e)\n        });\n      }\n    })();\n    return true;\n  }\n  else if (request.type === \"FOCUS_STATUS\") {\n    // Return the current focus state to the popup\n    getFocusState()\n      .then(focusState => sendResponse(focusState))\n      .catch(error => {\n        console.error(\"Error getting focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"CONTEXT_OVERRIDE\") {\n    // Handle context override (for analytics or future retraining)\n    console.log(`Context override: ${request.domain} from ${request.originalContext} to ${request.newContext}`);\n    \n    // We could log this for analytics or use it to improve the classifier\n    // For now, just acknowledge receipt\n    sendResponse({ success: true });\n    return true;\n  }\n  \n  return false; // No response needed for other messages\n});\n\n/**\n * Handle any focus mode toggle (enable/disable)\n */\nasync function toggleFocusMode(enabled: boolean): Promise<void> {\n  // This is a legacy function, but we'll keep it for compatibility with older UIs\n  if (enabled) {\n    // Legacy function, start with default settings\n    await focusEngine.start([\"Work\", \"Development\", \"Research\", \"Learning\"]);\n    \n    // Apply DNR blocking rules\n    await applyAllowedContexts();\n  } else {\n    // Turn off focus mode\n    await focusEngine.end();\n    \n    // Remove all blocking rules\n    await applyAllowedContexts();\n  }\n}\n\n/**\n * Handle context update with enhanced data\n */\nasync function handleContextUpdate(\n  tabId: number, \n  context: string, \n  contextData?: any\n): Promise<void> {\n  // Get current settings\n  const { autoGroupEnabled = true } = await getStorage([\n    \"autoGroupEnabled\",\n  ]);\n\n  // If auto-group is off, do nothing\n  if (autoGroupEnabled === false) {\n    return;\n  }\n\n  // Group tab by context\n  await groupTabByContext(tabId, context);\n  \n  // Update badge when context changes\n  updateBadge();\n  \n  // NEW: update domain → context map\n  const domain = extractDomain(contextData?.url || \"\");\n  if (domain) {\n    const { domainContextMap = {} } =\n      await chrome.storage.local.get(\"domainContextMap\") as { domainContextMap: Record<string,string> };\n    if (domainContextMap[domain] !== context) {\n      domainContextMap[domain] = context;\n      await chrome.storage.local.set({ domainContextMap });\n      await applyAllowedContexts();          // rebuild rules right away\n      \n      // check if this context should be blocked and redirect immediately if so\n      if (await focusEngine.isBlocked(context)) {\n        const url = contextData?.url || \"\";\n        const blockedUrl = chrome.runtime.getURL(\"blocked.html\") + \n          `?context=${encodeURIComponent(context)}&url=${encodeURIComponent(url)}`;\n        chrome.tabs.update(tabId, { url: blockedUrl });\n      }\n    }\n  }\n}\n\n/**\n * Updates the badge with current focus status\n */\nasync function updateBadge(): Promise<void> {\n  try {\n    const focusState = await getFocusState();\n    \n    // If not in focus mode, clear badge\n    if (!focusState.active) {\n      chrome.action.setBadgeText({ text: \"\" });\n      return;\n    }\n    \n    // Show a simple indicator\n    chrome.action.setBadgeText({ text: \"•\" });\n    chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n  } catch (error) {\n    console.error(\"Error updating badge:\", error);\n  }\n}\n\n/**\n * Send a high-visibility drift warning to the active tab\n */\nasync function sendDriftWarning(focusStatus: any): Promise<void> {\n  try {\n    // Always show warnings during focus sessions regardless of notification settings\n    // This is critical - users need to be alerted when drifting\n    \n    // Check if a focus session is active\n    const isSessionActive = await focusEngine.isActive();\n    if (!isSessionActive) {\n      return; // Only show drift warnings during active focus sessions\n    }\n    \n    console.log(\"[Focus] Sending drift warning to active tab\", focusStatus);\n    \n    // Get the active tab\n    const tabs = await chrome.tabs.query({active: true, currentWindow: true});\n    if (!tabs.length || !tabs[0].id) return;\n\n    const activeTab = tabs[0];\n    const tabId = activeTab.id as number;\n    \n    // Skip chrome:// pages and extension pages\n    if (\n      activeTab.url?.startsWith(\"chrome://\") || \n      activeTab.url?.startsWith(\"chrome-extension://\")\n    ) {\n      return;\n    }\n    \n    // Create a useful message about why focus was lost\n    let message = \"YOU'RE DRIFTING FROM YOUR FOCUS TASK!\";\n    \n    // If we have context switches, mention the last switch\n    if (focusStatus.contextSwitches.length > 0) {\n      const lastSwitch = focusStatus.contextSwitches[focusStatus.contextSwitches.length - 1];\n      message = `FOCUS LOST: Switched from ${lastSwitch.from} to ${lastSwitch.to}`;\n    }\n    \n    // Send the warning with callback to check if handled\n    chrome.tabs.sendMessage(tabId, {\n      type: \"DRIFT_WARNING\",\n      message\n    }, (resp) => {\n      if (chrome.runtime.lastError || resp === undefined) {\n        // Nobody listened - fall back to the blocked page\n        chrome.tabs.update(tabId, {url: BLOCKED_PAGE_URL});\n      }\n    });\n      \n    // Also show a system notification\n    chrome.notifications.create({\n      type: 'basic',\n      iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n      title: 'FOCUS ALERT!',\n      message: message,\n      priority: 2,\n      requireInteraction: true\n    });\n      \n    console.log(\"[Focus] Drift warning sent successfully\");\n  } catch (error) {\n    console.error(\"Error sending drift warning:\", error);\n  }\n}\n\n/**\n * Sets up blocking when a focus session is active\n * This is a no-op now because we use DNR rules for blocking\n */\nfunction setupFocusSessionUrlBlocking(): void {\n  // No action needed - DNR rules handle blocking\n}\n\n/**\n * Check if a focus session should be ended\n */\nasync function checkFocusSessionStatus(): Promise<void> {\n  const endTime = (await getFocusState()).endTime;\n  if (endTime && Date.now() >= endTime) {\n    const active = await focusEngine.isActive();\n    if (active) {\n      // Focus session time is up\n      await focusEngine.end();\n      console.log(\"[Focus] Session ended automatically due to timeout\");\n      \n      // Show notification to user\n      chrome.notifications.create({\n        type: 'basic',\n        iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n        title: 'Focus Session Complete',\n        message: `Your timed focus session has ended.`,\n      });\n    }\n  }\n}\n\n/**\n * Cleanup in-memory reference on tab removal\n */\nonTabRemoved((removedTabId) => {\n  delete tabContextMap[removedTabId];\n});\n\n// Function to get context data for a URL\nasync function getContextData(url: string): Promise<any> {\n  const result = await chrome.storage.local.get([url]);\n  return result[url] || { contexts: [], training: { falsePositives: [], truePositives: [] } };\n}\n\n// Function to save context data for a URL\nasync function saveContextData(url: string, data: any): Promise<void> {\n  await chrome.storage.local.set({ [url]: data });\n}\n\n// Function to update context weights based on training data\nasync function updateContextWeights(url: string): Promise<void> {\n  const contextData = await getContextData(url);\n  const { training } = contextData;\n  \n  if (!training) return;\n  \n  // Calculate weights based on false positives and true positives\n  const weights: { [key: string]: number } = {};\n  \n  // Decrease weight for contexts that frequently cause false positives\n  training.falsePositives.forEach((fp: any) => {\n    weights[fp.predictedContext] = (weights[fp.predictedContext] || 1) * 0.9;\n  });\n  \n  // Increase weight for contexts that are frequently true positives\n  training.truePositives.forEach((tp: any) => {\n    weights[tp.predictedContext] = (weights[tp.predictedContext] || 1) * 1.1;\n  });\n  \n  // Update context weights\n  contextData.weights = weights;\n  await saveContextData(url, contextData);\n}\n\n// Add listeners for focus state changes to update DNR rules\nchrome.storage.onChanged.addListener(async (changes) => {\n  if (changes.focusState) {\n    // Focus state has changed, update DNR rules\n    await applyAllowedContexts();\n  }\n});\n\n// Block before navigation is committed\nchrome.webNavigation.onBeforeNavigate.addListener(async ({ tabId, frameId, url }) => {\n  if (frameId !== 0) return;                     // only top frame\n  \n  // Skip extension pages and about:blank\n  if (url.startsWith(chrome.runtime.getURL(\"\")) || url === \"about:blank\") return;\n  \n  // Check if tab was recently unblocked - give it a pass\n  if (recentlyUnblockedTabs.has(tabId)) {\n    console.log(`[Block] Tab ${tabId} is in temporary allowlist, skipping check`);\n    return;\n  }\n  \n  const focusState = await getFocusState();\n  if (!focusState.active) return;\n\n  // Get current tab's URL to check if we're coming from blocked.html\n  try {\n    const tab = await chrome.tabs.get(tabId);\n    const currentUrl = tab.url || \"\";\n    \n    // If user is coming from the blocked page, allow them to navigate and add to temporary allowlist\n    if (currentUrl.includes(\"blocked.html\")) {\n      console.log(`[Block] Tab ${tabId} coming from blocked page, allowing navigation`);\n      recentlyUnblockedTabs.add(tabId);\n      \n      // Remove from allowlist after 5 seconds\n      setTimeout(() => {\n        recentlyUnblockedTabs.delete(tabId);\n        console.log(`[Block] Tab ${tabId} removed from temporary allowlist`);\n      }, 5000);\n      \n      return;\n    }\n  } catch (err) {\n    // Continue if tab lookup fails\n  }\n\n  // Check if the domain is already classified and should be blocked\n  const domain = extractDomain(url);\n  const ctxMap = (await chrome.storage.local.get(\"domainContextMap\")).domainContextMap || {};\n  const context = ctxMap[domain];\n  \n  // Only block if we have a context and it's not allowed\n  if (context && !focusState.allowedContexts.includes(context)) {\n    console.log(`[Block] Blocking domain ${domain} with context ${context}`);\n    // Pass context and original URL as query parameters\n    const blockedUrl = chrome.runtime.getURL(\"blocked.html\") + \n      `?context=${encodeURIComponent(context)}&url=${encodeURIComponent(url)}`;\n    chrome.tabs.update(tabId, { url: blockedUrl });\n  }\n});\n\n// Set default settings on installation/update\nchrome.runtime.onInstalled.addListener(details => {\n  if (details.reason === \"install\") {\n    // First-time install: set defaults\n    chrome.storage.local.set({\n      extensionEnabled: true,\n      autoGroupEnabled: true, // Set auto grouping enabled by default\n      focusState: {\n        active: false,\n        allowedContexts: []\n      },\n      firstRunComplete: false\n    });\n    \n    // Show onboarding page\n    chrome.tabs.create({ url: chrome.runtime.getURL(\"onboarding.html\") });\n  } else if (details.reason === \"update\") {\n    // Handle migration from old storage format to new\n    chrome.storage.local.get([\n      \"autoGroupEnabled\", // Check for this setting\n      \"focusSessionActive\", \n      \"focusSessionEndTime\",\n      \"blockedCategories\",\n      \"focusState\"\n    ], result => {\n      // Always set extension to enabled\n      const update: Record<string, any> = {\n        extensionEnabled: true\n      };\n      \n      // Migration: If we have old format data but no new focusState yet, convert it\n      if (!result.focusState && (result.focusSessionActive || result.blockedCategories)) {\n        console.log(\"Migrating from old focus session format to new focusState format\");\n        \n        // Convert to new FocusState format (invert the block logic to allowedContexts)\n        const knownContexts = [\n          \"Work\", \"Development\", \"Research\", \"Learning\", \n          \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n        ];\n        \n        // Calculate allowed contexts by excluding blocked ones\n        const blockedCategories = result.blockedCategories || [];\n        const allowedContexts = knownContexts.filter(ctx => !blockedCategories.includes(ctx));\n        \n        update.focusState = {\n          active: result.focusSessionActive === true,\n          allowedContexts,\n          endTime: result.focusSessionEndTime || undefined\n        };\n        \n        // Remove old keys after migration\n        chrome.storage.local.remove([\n          \"focusSessionActive\", \n          \"focusSessionEndTime\", \n          \"blockedCategories\"\n        ]);\n      }\n      \n      // Ensure we have explicit boolean values, not undefined  \n      if (result.autoGroupEnabled === undefined) update.autoGroupEnabled = true;\n      \n      // Apply all updates\n      chrome.storage.local.set(update);\n    });\n  }\n});\n\n// Kick off on load\ninitExtension().catch(console.error);","import { getStorage, setStorage } from \"./storageApi\";\nimport { ParkedLink } from \"../types/index\";\n\n/**\n * Save a link for later viewing\n */\nexport async function saveForLater(url: string, context: string, title?: string): Promise<void> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  \n  // Check if the URL is already parked to avoid duplicates\n  const isDuplicate = parkedLinks.some(link => link.url === url);\n  \n  if (!isDuplicate) {\n    const newLink: ParkedLink = {\n      url,\n      title,\n      context,\n      timestamp: Date.now()\n    };\n    \n    await setStorage({\n      parkedLinks: [...parkedLinks, newLink]\n    });\n  }\n}\n\n/**\n * Get all parked links\n */\nexport async function getParkedLinks(): Promise<ParkedLink[]> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  return parkedLinks;\n}\n\n/**\n * Open all parked links in new tabs and clear the list\n */\nexport async function releaseParkedLinks(): Promise<void> {\n  const parkedLinks = await getParkedLinks();\n  \n  if (parkedLinks.length === 0) {\n    return;\n  }\n  \n  // Create a new tab group for the parked links\n  const currentWindow = await chrome.windows.getCurrent();\n  let groupId: number | undefined;\n  \n  try {\n    // Open all the links in new tabs\n    const openedTabIds: number[] = [];\n    \n    for (const link of parkedLinks) {\n      const tab = await chrome.tabs.create({\n        url: link.url,\n        active: false\n      });\n      \n      if (tab.id) {\n        openedTabIds.push(tab.id);\n      }\n    }\n    \n    // Group the tabs if we have any\n    if (openedTabIds.length > 0) {\n      try {\n        groupId = await chrome.tabs.group({\n          tabIds: openedTabIds\n        });\n        \n        if (groupId) {\n          await chrome.tabGroups.update(groupId, {\n            title: \"Parked Links\",\n            color: \"blue\"\n          });\n        }\n      } catch (groupError) {\n        console.error(\"Error creating tab group:\", groupError);\n      }\n    }\n    \n    // Clear the parked links list\n    await setStorage({ parkedLinks: [] });\n    \n    // Show a notification\n    chrome.notifications.create({\n      type: \"basic\",\n      iconUrl: chrome.runtime.getURL(\"icons/icon48.png\"),\n      title: \"Parked Links Opened\",\n      message: `Opened ${parkedLinks.length} links that were saved during your focus session.`\n    });\n  } catch (error) {\n    console.error(\"Error opening parked links:\", error);\n  }\n}\n\n/**\n * More robust function to navigate back or close the current tab\n */\nexport async function goBackOrClose(tabId: number): Promise<void> {\n  try {\n    // Get tab info first to confirm it exists\n    const tab = await chrome.tabs.get(tabId);\n    \n    // First try to determine if we can go back using script injection\n    try {\n      const historyResults = await chrome.scripting.executeScript({\n        target: { tabId },\n        func: () => ({\n          canGoBack: window.history.length > 1,\n          url: window.location.href\n        })\n      });\n      \n      const { canGoBack } = historyResults[0].result;\n      \n      if (canGoBack) {\n        // Navigate back if possible using script injection\n        await chrome.scripting.executeScript({\n          target: { tabId },\n          func: () => window.history.back()\n        });\n        \n        // Success, we're done\n        return;\n      }\n      \n      // Can't go back, use fallback approach\n      await handleNavigationFallback(tabId, tab);\n    } catch (err) {\n      console.error(\"Script execution error:\", err);\n      \n      // Fallback to simpler chrome.tabs.goBack API\n      try {\n        await chrome.tabs.goBack(tabId);\n      } catch (backError) {\n        // If that fails too, use final fallback\n        await handleNavigationFallback(tabId, tab);\n      }\n    }\n  } catch (err) {\n    console.error(\"Tab lookup error:\", err);\n    // Tab might no longer exist, nothing to do\n  }\n}\n\n/**\n * Fallback navigation handler when going back isn't possible\n */\nasync function handleNavigationFallback(tabId: number, tab: chrome.tabs.Tab): Promise<void> {\n  try {\n    // Get all tabs in the window\n    const allTabs = await chrome.tabs.query({ windowId: tab.windowId });\n    \n    if (allTabs.length > 1) {\n      // More than one tab, find one to focus\n      const currentIndex = allTabs.findIndex(t => t.id === tabId);\n      const targetIndex = currentIndex > 0 ? currentIndex - 1 : (currentIndex + 1) % allTabs.length;\n      const targetTab = allTabs[targetIndex];\n      \n      // Focus the other tab first\n      if (targetTab.id) {\n        await chrome.tabs.update(targetTab.id, { active: true });\n        \n        // Then remove the current tab\n        setTimeout(() => {\n          chrome.tabs.remove(tabId).catch(e => {\n            console.error(\"Tab removal failed:\", e);\n          });\n        }, 100);\n      }\n    } else {\n      // Last tab, navigate to blank page instead\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    }\n  } catch (e) {\n    console.error(\"Navigation fallback failed:\", e);\n    // Last resort - try basic navigation\n    try {\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    } catch (finalError) {\n      console.error(\"Final fallback failed:\", finalError);\n    }\n  }\n}\n\n/**\n * Show a toast notification in the current tab\n */\nexport async function showToast(tabId: number, message: string, duration = 3000): Promise<void> {\n  try {\n    await chrome.scripting.executeScript({\n      target: { tabId },\n      func: (msg: string, dur: number) => {\n        const toast = document.createElement(\"div\");\n        toast.style.cssText = `\n          position: fixed;\n          bottom: 20px;\n          right: 20px;\n          background-color: rgba(0, 102, 204, 0.9);\n          color: white;\n          padding: 12px 20px;\n          border-radius: 4px;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n          font-family: Arial, sans-serif;\n          z-index: 2147483647;\n          max-width: 300px;\n          transition: opacity 0.3s ease-in-out;\n        `;\n        toast.textContent = msg;\n        document.body.appendChild(toast);\n        \n        // Fade out and remove\n        setTimeout(() => {\n          toast.style.opacity = \"0\";\n          setTimeout(() => toast.remove(), 300);\n        }, dur - 300);\n      },\n      args: [message, duration]\n    });\n  } catch (error) {\n    console.error(\"Error showing toast:\", error);\n  }\n}\n\n/**\n * Clear all parked links without opening them\n */\nexport async function clearParkedLinks(): Promise<void> {\n  await setStorage({ parkedLinks: [] });\n} ","import { pickColorForContext } from \"../lib/pickColor\";\n\nexport async function groupTabByContext(tabId: number, context: string): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  let existingGroup = groups.find((grp) => grp.title === context);\n\n  if (!existingGroup) {\n    // Create new group if none match\n    const newGroupId = await chrome.tabs.group({ tabIds: [tabId] });\n    existingGroup = await chrome.tabGroups.update(newGroupId, {\n      title: context,\n      color: pickColorForContext(context),\n    });\n  } else {\n    // Add to existing group\n    await chrome.tabs.group({ groupId: existingGroup.id, tabIds: [tabId] });\n  }\n}\n\nexport function onTabRemoved(callback: (tabId: number) => void): void {\n  chrome.tabs.onRemoved.addListener(callback);\n}\n\n/** Ungroup every tab in every window */\nexport async function ungroupAllTabs(): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  for (const g of groups) {\n    const tabs = await chrome.tabs.query({ groupId: g.id });\n    if (tabs.length) {\n      await chrome.tabs.ungroup(tabs.map(t => t.id!));\n    }\n  }\n}","import { getStorage, setStorage } from \"./storageApi\";\nimport { FocusStatus, FocusSettings, ContextSwitch } from \"../types/index\";\n\nconst DEFAULT_FOCUS_SETTINGS: FocusSettings = {\n  enabled: true,\n  notificationsEnabled: true,\n  switchThreshold: 5,\n  timeWindowMinutes: 15\n};\n\n/**\n * Get the current focus settings\n */\nexport async function getFocusSettings(): Promise<FocusSettings> {\n  const { focusSettings } = await getStorage([\"focusSettings\"]);\n  return { ...DEFAULT_FOCUS_SETTINGS, ...focusSettings };\n}\n\n/**\n * Update focus settings\n */\nexport async function updateFocusSettings(settings: Partial<FocusSettings>): Promise<void> {\n  const currentSettings = await getFocusSettings();\n  await setStorage({ \n    focusSettings: { ...currentSettings, ...settings } \n  });\n}\n\n/**\n * Get context switches in a time window\n */\nexport async function getContextSwitches(timeWindowMinutes: number = 15): Promise<ContextSwitch[]> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (!contextHistory || contextHistory.length < 2) {\n    return [];\n  }\n  \n  const switches: ContextSwitch[] = [];\n  const now = Date.now();\n  const timeWindow = timeWindowMinutes * 60 * 1000;\n  \n  // Filter history to time window\n  const relevantHistory = contextHistory.filter(\n    entry => (now - entry.timestamp) < timeWindow\n  );\n  \n  // Find context switches\n  for (let i = 1; i < relevantHistory.length; i++) {\n    if (relevantHistory[i].context !== relevantHistory[i-1].context) {\n      switches.push({\n        from: relevantHistory[i-1].context,\n        to: relevantHistory[i].context,\n        timestamp: relevantHistory[i].timestamp,\n        fromUrl: relevantHistory[i-1].url,\n        toUrl: relevantHistory[i].url\n      });\n    }\n  }\n  \n  return switches;\n}\n\n/**\n * Check if focus is lost based on context switching\n */\nexport async function checkFocusStatus(): Promise<FocusStatus> {\n  const settings = await getFocusSettings();\n  const switches = await getContextSwitches(settings.timeWindowMinutes);\n  \n  let currentContext = \"Unknown\";\n  let currentStreak = 1;\n  \n  // Get most recent context and streak\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (contextHistory && contextHistory.length > 0) {\n    currentContext = contextHistory[contextHistory.length - 1].context;\n    \n    // Count consecutive entries with same context\n    let i = contextHistory.length - 1;\n    while (i > 0 && contextHistory[i].context === currentContext) {\n      currentStreak++;\n      i--;\n    }\n  }\n  \n  // Determine if focus is lost\n  const isLostFocus = switches.length >= settings.switchThreshold;\n  \n  return {\n    isLostFocus,\n    contextSwitches: switches,\n    currentStreak,\n    currentContext\n  };\n}\n\n/**\n * Show focus notification\n */\nexport function showFocusNotification(contextSwitches: ContextSwitch[]): void {\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Alert',\n    message: `You've switched contexts ${contextSwitches.length} times recently. Try to maintain focus.`,\n    buttons: [\n      { title: 'View Details' }\n    ]\n  });\n}","/**\n * Declarative Net Request rules for efficient content blocking\n */\nimport { getFocusState } from \"../api/storageApi\";\n\n// Constants\nconst RULE_ID_OFFSET = 100;\nconst MAX_DNR_RULES = 5000;\nconst BLOCKED_PAGE_URL = chrome.runtime.getURL(\"blocked.html\");\n\n/**\n * Apply allowed contexts as declarative blocking rules\n * \n * This function takes the current allowed contexts and creates dynamic DNR rules\n * to block all requests to domains that are categorized outside those contexts.\n */\nexport async function applyAllowedContexts(): Promise<void> {\n  try {\n    // Get the current focus state\n    const focusState = await getFocusState();\n    \n    // If focus is not active, remove all rules\n    if (!focusState.active) {\n      await chrome.declarativeNetRequest.updateDynamicRules({\n        removeRuleIds: await getCurrentRuleIds()\n      });\n      return;\n    }\n    \n    // Get domains classified by context\n    const { domainContextMap } = await chrome.storage.local.get('domainContextMap') as { \n      domainContextMap: Record<string, string> \n    };\n    \n    if (!domainContextMap) {\n      console.warn(\"No domain context map found, cannot create blocking rules\");\n      return;\n    }\n    \n    // Group domains by context\n    const domainsByContext: Record<string, string[]> = {};\n    for (const [domain, context] of Object.entries(domainContextMap)) {\n      if (!domainsByContext[context]) {\n        domainsByContext[context] = [];\n      }\n      domainsByContext[context].push(domain);\n    }\n    \n    // Create rules for each blocked context\n    const rules: chrome.declarativeNetRequest.Rule[] = [];\n    const blockedContexts = getAllKnownContexts().filter(\n      ctx => !focusState.allowedContexts.includes(ctx)\n    );\n    \n    let ruleId = RULE_ID_OFFSET;\n    \n    for (const context of blockedContexts) {\n      const domains = domainsByContext[context] || [];\n      \n      // Skip if no domains in this context\n      if (domains.length === 0) continue;\n      \n      // Add a rule for this context\n      rules.push({\n        id: ruleId++,\n        priority: 1,\n        action: {\n          type: chrome.declarativeNetRequest.RuleActionType.REDIRECT,\n          redirect: { url: BLOCKED_PAGE_URL }\n        },\n        condition: {\n          requestDomains: domains,\n          resourceTypes: [chrome.declarativeNetRequest.ResourceType.MAIN_FRAME],\n          // Exclude all extensions and localhost from blocking\n          excludedInitiatorDomains: ['localhost', 'chrome-extension'],\n          // Only apply to new navigations, not history navigations\n          domainType: chrome.declarativeNetRequest.DomainType.FIRST_PARTY\n        }\n      });\n      \n      // DNR has a rule limit, so break if we hit it\n      if (rules.length >= MAX_DNR_RULES) {\n        console.warn(`Hit DNR rule limit of ${MAX_DNR_RULES}`);\n        break;\n      }\n    }\n    \n    // Add path-level overrides if any exist\n    const { pathOverrides = [] } = await chrome.storage.local.get('pathOverrides') as { \n      pathOverrides: string[] \n    };\n    \n    // Add each path override as a separate rule\n    for (const overridePath of pathOverrides) {\n      rules.push({\n        id: ruleId++,\n        priority: 2, // Higher priority than domain rules\n        action: { \n          type: chrome.declarativeNetRequest.RuleActionType.REDIRECT, \n          redirect: { url: BLOCKED_PAGE_URL } \n        },\n        condition: {\n          urlFilter: `|${overridePath}|`,\n          resourceTypes: [chrome.declarativeNetRequest.ResourceType.MAIN_FRAME]\n        }\n      });\n      \n      // DNR has a rule limit, so break if we hit it\n      if (rules.length >= MAX_DNR_RULES) {\n        console.warn(`Hit DNR rule limit of ${MAX_DNR_RULES}`);\n        break;\n      }\n    }\n    \n    // Apply the rules\n    await chrome.declarativeNetRequest.updateDynamicRules({\n      removeRuleIds: await getCurrentRuleIds(),\n      addRules: rules\n    });\n    \n    console.log(`[DNR] Applied ${rules.length} blocking rules for ${blockedContexts.length} contexts and ${pathOverrides.length} path overrides`);\n  } catch (error) {\n    console.error(\"Error applying DNR rules:\", error);\n  }\n}\n\n/**\n * Get current active rule IDs\n */\nasync function getCurrentRuleIds(): Promise<number[]> {\n  const rules = await chrome.declarativeNetRequest.getDynamicRules();\n  return rules.map(rule => rule.id);\n}\n\n/**\n * Get all known context categories\n */\nfunction getAllKnownContexts(): string[] {\n  return [\n    \"Work\", \"Development\", \"Research\", \"Learning\", \n    \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n  ];\n} ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(545);\n"],"names":["getStorage","keys","Promise","resolve","reject","chrome","storage","local","get","result","runtime","lastError","setStorage","data","set","async","getFocusState","focusState","active","allowedContexts","context","url","confidence","contextHistory","newHistory","push","timestamp","Date","now","length","shift","partialState","currentState","focusWindowId","launchFocusWindow","undefined","windows","error","id","create","type","state","tabs","query","windowId","update","getURL","console","remove","tabId","move","index","blockClearTimer","recentlyBlocked","allowed","durationMin","safeAllowed","Array","isArray","endTime","setFocusState","blockedCategories","filter","ctx","includes","openSidePanel","focusSettings","focusWindowEnabled","action","setBadgeText","text","setBadgeBackgroundColor","color","notifications","iconUrl","title","message","priority","saveWorkspaceName","groups","tabGroups","workspaceGroups","all","map","grp","groupId","tabUrls","t","savedWorkspaces","newWorkspaceEntry","name","updatedWorkspaces","closeSidePanel","closeFocusWindow","ungroupAllTabs","clearTimeout","releaseParkedLinks","log","setTimeout","Math","max","workspace","find","ws","tabIds","createdTab","newGroupId","group","currentWindow","getCurrent","sidePanel","open","panels","getAll","panel","close","path","setOptions","enabled","extractDomain","URL","hostname","getDomainCategory","domain","DOMAIN_CATEGORIES","startsWith","withoutWww","substring","parts","split","parentDomain","slice","join","extractPathKeywords","pathname","Boolean","flatMap","segment","word","domainCategory","scores","tabContextMap","BLOCKED_PAGE_URL","recentlyUnblockedTabs","Set","updateBadge","getContextData","contexts","training","falsePositives","truePositives","saveContextData","onMessage","addListener","request","sender","sendResponse","tab","contextData","secondaryContexts","autoGroupEnabled","groupTabByContext","domainContextMap","applyAllowedContexts","focusEngine","isBlocked","blockedUrl","encodeURIComponent","handleContextUpdate","catch","err","start","end","toggleFocusMode","durationMinutes","payload","then","success","getTimeLeft","seconds","add","delete","restoreWorkspace","checkFocusStatus","sendMessage","resp","saveForLater","String","actualContext","predictedContext","isFalsePositive","weights","forEach","fp","tp","updateContextWeights","goBackOrClose","e","Error","originalContext","newContext","onTabRemoved","removedTabId","onChanged","changes","webNavigation","onBeforeNavigate","frameId","has","onInstalled","details","reason","extensionEnabled","firstRunComplete","focusSessionActive","knownContexts","focusSessionEndTime","toLocaleTimeString","alarms","periodInMinutes","onAlarm","isActive","checkFocusSessionStatus","focusStatus","isLostFocus","activeTab","contextSwitches","lastSwitch","from","to","requireInteraction","sendDriftWarning","initExtension","getParkedLinks","parkedLinks","handleNavigationFallback","allTabs","currentIndex","findIndex","targetTab","finalError","some","link","newLink","openedTabIds","groupError","historyResults","scripting","executeScript","target","func","canGoBack","window","history","location","href","back","goBack","backError","duration","msg","dur","toast","document","createElement","style","cssText","textContent","body","appendChild","opacity","args","existingGroup","pickColorForContext","callback","onRemoved","g","ungroup","DEFAULT_FOCUS_SETTINGS","notificationsEnabled","switchThreshold","timeWindowMinutes","getFocusSettings","getContextSwitches","switches","timeWindow","relevantHistory","entry","i","fromUrl","toUrl","settings","currentSettings","currentContext","currentStreak","buttons","getCurrentRuleIds","declarativeNetRequest","getDynamicRules","rule","updateDynamicRules","removeRuleIds","warn","domainsByContext","Object","entries","rules","blockedContexts","ruleId","domains","RuleActionType","REDIRECT","redirect","condition","requestDomains","resourceTypes","ResourceType","MAIN_FRAME","excludedInitiatorDomains","domainType","DomainType","FIRST_PARTY","pathOverrides","overridePath","urlFilter","addRules","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}