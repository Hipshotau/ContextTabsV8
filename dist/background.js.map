{"version":3,"file":"background.js","mappings":"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","sources":["webpack://context-focus/./src/api/storageApi.ts","webpack://context-focus/./src/lib/windows/focusWindow.ts","webpack://context-focus/./src/lib/pickColor.ts","webpack://context-focus/./src/lib/focusEngine.ts","webpack://context-focus/./src/lib/panels/sidePanelManager.ts","webpack://context-focus/./src/api/focusSessionManager.ts","webpack://context-focus/./src/background/index.ts","webpack://context-focus/./src/api/parkedLinksApi.ts","webpack://context-focus/./src/api/tabsApi.ts","webpack://context-focus/./src/api/focusApi.ts","webpack://context-focus/webpack/bootstrap","webpack://context-focus/webpack/startup"],"sourcesContent":["import { FocusSettings, StorageData as TypesStorageData, FocusState } from \"../types/index\";\n\n// Re-export the StorageData interface from types/index.d.ts\nexport type StorageData = TypesStorageData;\n\n/**\n * Get an object containing the requested keys.\n */\nexport function getStorage<T extends keyof StorageData>(\n  keys: T[]\n): Promise<Pick<StorageData, T>> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.get(keys, (result) => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve(result as Pick<StorageData, T>);\n    });\n  });\n}\n\n/**\n * Set or update the given keys in storage.\n */\nexport function setStorage(data: Partial<StorageData>): Promise<void> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.set(data, () => {\n      if (chrome.runtime.lastError) {\n        return reject(chrome.runtime.lastError);\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * Add a context entry to history\n */\nexport async function addContextToHistory(\n  context: string,\n  url: string,\n  confidence: number\n): Promise<void> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  const newHistory = contextHistory || [];\n  \n  // Add new entry\n  newHistory.push({\n    context,\n    url,\n    timestamp: Date.now(),\n    confidence\n  });\n  \n  // Limit history size\n  if (newHistory.length > 100) {\n    newHistory.shift();\n  }\n  \n  await setStorage({ contextHistory: newHistory });\n}\n\n/**\n * Get the current focus state\n */\nexport async function getFocusState(): Promise<FocusState> {\n  const { focusState } = await getStorage([\"focusState\"]);\n  \n  // Default state if none exists\n  const defaultState: FocusState = {\n    active: false,\n    allowedContexts: []\n  };\n  \n  return { ...defaultState, ...focusState };\n}\n\n/**\n * Update the focus state\n */\nexport async function setFocusState(partialState: Partial<FocusState>): Promise<void> {\n  const currentState = await getFocusState();\n  await setStorage({ \n    focusState: { ...currentState, ...partialState }\n  });\n}","let focusWindowId: number | undefined;\n\n/**\n * Create a dedicated window for the focus session\n * This creates a new window that can be populated with productive tabs\n */\nexport async function launchFocusWindow(): Promise<number | undefined> {\n  try {\n    // Check if focus window already exists\n    if (focusWindowId !== undefined) {\n      try {\n        // Try to get window to verify it still exists\n        await chrome.windows.get(focusWindowId);\n        return focusWindowId; // Window already exists\n      } catch (error) {\n        // Window doesn't exist anymore, reset the ID\n        focusWindowId = undefined;\n      }\n    }\n\n    // Create a new window\n    const { id } = await chrome.windows.create({\n      url: \"about:blank\",\n      type: \"normal\",\n      state: \"maximized\"\n    });\n    \n    focusWindowId = id;\n    \n    // Create a welcoming tab\n    if (id) {\n      const tabs = await chrome.tabs.query({ windowId: id });\n      \n      // If there's at least one tab (the default about:blank), update it\n      if (tabs.length > 0 && tabs[0].id) {\n        await chrome.tabs.update(tabs[0].id, { \n          url: chrome.runtime.getURL(\"blocked.html\") + \"?mode=welcome\" \n        });\n      }\n    }\n    \n    return focusWindowId;\n  } catch (error) {\n    console.error(\"Error launching focus window:\", error);\n    return undefined;\n  }\n}\n\n/**\n * Close the dedicated focus window\n */\nexport async function closeFocusWindow(): Promise<void> {\n  if (focusWindowId === undefined) return;\n  \n  try {\n    await chrome.windows.remove(focusWindowId);\n    focusWindowId = undefined;\n  } catch (error) {\n    console.error(\"Error closing focus window:\", error);\n    // Reset the ID even if there was an error\n    focusWindowId = undefined;\n  }\n}\n\n/**\n * Check if the focus window is active\n */\nexport function getFocusWindowId(): number | undefined {\n  return focusWindowId;\n}\n\n/**\n * Move a tab to the focus window\n */\nexport async function moveTabToFocusWindow(tabId: number): Promise<boolean> {\n  if (focusWindowId === undefined) {\n    const windowId = await launchFocusWindow();\n    if (windowId === undefined) return false;\n  }\n  \n  try {\n    await chrome.tabs.move(tabId, { windowId: focusWindowId!, index: -1 });\n    return true;\n  } catch (error) {\n    console.error(\"Error moving tab to focus window:\", error);\n    return false;\n  }\n} ","export function pickColorForContext(context: string): chrome.tabGroups.ColorEnum {\n  switch (context) {\n    case \"Work\":\n      return \"yellow\";\n    case \"Learning\":\n      return \"blue\";\n    case \"Entertainment\":\n      return \"green\";\n    case \"News\":\n      return \"red\";\n    case \"Shopping\":\n      return \"purple\";\n    case \"Social\":\n      return \"cyan\";\n    case \"Research\":\n      return \"pink\";\n    case \"Development\":\n      return \"orange\";\n    default:\n      return \"grey\";  // Chrome uses \"grey\" (British spelling) not \"gray\"\n  }\n}","/**\n * Focus Engine - Core logic for the Focus feature\n * \n * This module implements the state machine for focus mode, following the principle\n * of \"block by exclusion\" - where user picks ALLOWED contexts and everything else is blocked.\n */\n\nimport { getFocusState, setFocusState } from \"../api/storageApi\";\nimport { FocusState } from \"../types/index\";\n\n// State for tracking if a navigation was blocked recently (for badge alert)\nlet recentlyBlocked = false;\nlet blockClearTimer: NodeJS.Timeout | undefined;\nlet endTimeCheckInterval: NodeJS.Timeout | undefined;\n\n/**\n * Start a focus session\n * \n * @param allowed - Array of context categories that are allowed during focus\n * @param durationMin - Optional duration in minutes after which focus will automatically end\n */\nexport async function start(allowed: string[], durationMin?: number): Promise<void> {\n  // Calculate end time if duration is provided\n  const endTime = durationMin ? Date.now() + durationMin * 60 * 1000 : undefined;\n  \n  // Save focus state\n  await setFocusState({\n    active: true,\n    allowedContexts: allowed,\n    endTime\n  });\n  \n  // Set badge to show focus is active\n  chrome.action.setBadgeText({ text: \"•\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n  \n  // Setup interval to check for timer expiration\n  if (endTime) {\n    if (endTimeCheckInterval) {\n      clearInterval(endTimeCheckInterval);\n    }\n    \n    endTimeCheckInterval = setInterval(async () => {\n      const focusState = await getFocusState();\n      \n      if (focusState.active && focusState.endTime && focusState.endTime <= Date.now()) {\n        // Timer expired, end focus session\n        console.log(\"Focus timer expired automatically\");\n        end();\n        \n        // Show a notification\n        chrome.notifications.create({\n          type: 'basic',\n          iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n          title: 'Focus Session Ended',\n          message: 'Your focus session has ended. Great job!',\n          priority: 2\n        });\n      }\n    }, 15000); // Check every 15 seconds\n  }\n}\n\n/**\n * End a focus session\n */\nexport async function end(): Promise<void> {\n  // Clear focus state\n  await setFocusState({\n    active: false,\n    endTime: undefined\n  });\n  \n  // Clear badge\n  chrome.action.setBadgeText({ text: \"\" });\n  \n  // Clear timer interval\n  if (endTimeCheckInterval) {\n    clearInterval(endTimeCheckInterval);\n    endTimeCheckInterval = undefined;\n  }\n  \n  // Reset block indicator\n  recentlyBlocked = false;\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n    blockClearTimer = undefined;\n  }\n}\n\n/**\n * Check if a context should be blocked\n * \n * @param context - The context category to check\n * @returns true if the context should be blocked, false otherwise\n */\nexport async function isBlocked(context: string): Promise<boolean> {\n  const focusState = await getFocusState();\n  \n  // If focus is not active, nothing is blocked\n  if (!focusState.active) {\n    return false;\n  }\n  \n  // If context is in allowed list, it's not blocked\n  if (focusState.allowedContexts.includes(context)) {\n    return false;\n  }\n  \n  // Context is not in allowed list, so it's blocked\n  // Update the \"recently blocked\" state for badge\n  recentlyBlocked = true;\n  \n  // Show red \"!\" badge\n  chrome.action.setBadgeText({ text: \"!\" });\n  chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red\n  \n  // Clear the blocked indicator after 30 seconds\n  if (blockClearTimer) {\n    clearTimeout(blockClearTimer);\n  }\n  \n  blockClearTimer = setTimeout(() => {\n    if (recentlyBlocked) {\n      recentlyBlocked = false;\n      // Restore the normal focus badge\n      chrome.action.setBadgeText({ text: \"•\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue\n    }\n  }, 30000);\n  \n  return true;\n}\n\n/**\n * Check if a focus session is currently active\n * \n * @returns true if a focus session is active, false otherwise\n */\nexport async function isActive(): Promise<boolean> {\n  const focusState = await getFocusState();\n  return focusState.active;\n}\n\n/**\n * Get the time left in the current focus session in minutes\n * \n * @returns Minutes left in the focus session, or 0 if no session or no timer\n */\nexport async function getTimeLeft(): Promise<number> {\n  const focusState = await getFocusState();\n  \n  if (!focusState.active || !focusState.endTime) {\n    return 0;\n  }\n  \n  const timeLeftMs = Math.max(0, focusState.endTime - Date.now());\n  return Math.floor(timeLeftMs / 60000); // Convert to minutes\n} ","/**\n * Open the side panel in the current window\n */\nexport async function openSidePanel(): Promise<void> {\n  try {\n    const currentWindow = await chrome.windows.getCurrent();\n    await chrome.sidePanel.open({ windowId: currentWindow.id });\n    console.log(\"Side panel opened successfully\");\n  } catch (error) {\n    console.error(\"Error opening side panel:\", error);\n  }\n}\n\n/**\n * Close the side panel in all windows\n */\nexport async function closeSidePanel(): Promise<void> {\n  try {\n    const panels = await chrome.sidePanel.getAll();\n    await Promise.all(panels.map((panel: chrome.sidePanel.PanelInfo) => \n      chrome.sidePanel.close({ windowId: panel.windowId })\n    ));\n    console.log(\"Side panels closed successfully\");\n  } catch (error) {\n    console.error(\"Error closing side panels:\", error);\n  }\n}\n\n/**\n * Set the side panel properties\n */\nexport async function setSidePanelProperties(path: string, title: string): Promise<void> {\n  try {\n    await chrome.sidePanel.setOptions({\n      path,\n      enabled: true\n    });\n    console.log(\"Side panel properties updated\");\n  } catch (error) {\n    console.error(\"Error setting side panel properties:\", error);\n  }\n} ","import { getStorage, setStorage, getFocusState, setFocusState } from \"./storageApi\";\nimport { StorageData } from \"../types/index\";\nimport { groupTabByContext, ungroupAllTabs } from \"./tabsApi\";\nimport { classifyPageContext } from \"../lib/contextEngine\";\nimport { extractDomain } from \"../lib/contextEngine/urlAnalyzer\";\nimport { launchFocusWindow, closeFocusWindow } from \"../lib/windows/focusWindow\";\nimport { openSidePanel, closeSidePanel } from \"../lib/panels/sidePanelManager\";\nimport { releaseParkedLinks } from \"./parkedLinksApi\";\n\n// Set up periodic badge updates\nlet badgeUpdateInterval: number | undefined;\n\n// Flag to track if alarm listener is already set up\nlet alarmListenerRegistered = false;\n\n/**\n * Start a Focus Session with a specified duration (minutes) and a set of blocked categories.\n * Activates all visual, auditory, and spatial cues for maximum ADHD-friendly feedback.\n */\nexport async function startFocusSession(durationMinutes: number, blockedCategories: string[]): Promise<void> {\n  const now = Date.now();\n  const endTime = now + durationMinutes * 60_000;\n\n  // Convert blockedCategories to allowedContexts by excluding them from all known contexts\n  const knownContexts = [\n    \"Work\", \"Development\", \"Research\", \"Learning\", \n    \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n  ];\n  const allowedContexts = knownContexts.filter(ctx => !blockedCategories.includes(ctx));\n\n  // Mark focus session as active using the new focusState object\n  await setFocusState({\n    active: true,\n    allowedContexts,\n    endTime\n  });\n\n  // Also store blockedCategories for backward compatibility with UI\n  await setStorage({ blockedCategories });\n\n  // Open the side panel for persistent timer display\n  await openSidePanel();\n\n  // Update the badge and icon to indicate focus mode\n  updateBadge(durationMinutes, false);\n  \n  // Set up alarms for badge updates instead of setInterval\n  chrome.alarms.create('badgeUpdate', { periodInMinutes: 0.2 });\n  \n  // Set up the alarm listener only once\n  if (!alarmListenerRegistered) {\n    chrome.alarms.onAlarm.addListener(async (alarm) => {\n      if (alarm.name !== 'badgeUpdate') return;\n      const timeLeft = await getFocusSessionTimeLeft();\n      const drifting = await checkIfDrifting();\n      updateBadge(timeLeft / 60, drifting); // Convert seconds to minutes\n    });\n    \n    alarmListenerRegistered = true;\n  }\n  \n  // Optionally launch a dedicated focus window\n  const storage = await getStorage([\"focusSettings\"]);\n  const focusWindowEnabled = storage.focusSettings?.focusWindowEnabled || false;\n  if (focusWindowEnabled) {\n    await launchFocusWindow();\n  }\n\n  // Show notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Started',\n    message: `Focus session started for ${durationMinutes} minutes. Stay focused!`,\n  });\n}\n\n/**\n * End the current Focus Session.\n * Optionally save the workspace (tab groups) if user requests.\n */\nexport async function endFocusSession(saveWorkspace: boolean, workspaceName: string = \"\"): Promise<void> {\n  // If user wants to save workspace, store it\n  if (saveWorkspace && workspaceName) {\n    await saveCurrentWorkspace(workspaceName);\n  }\n\n  // Clear focus state using the new API\n  await setFocusState({\n    active: false,\n    endTime: undefined\n  });\n  \n  // Close the side panel\n  await closeSidePanel();\n  \n  // Ungroup all tabs\n  await ungroupAllTabs();\n  \n  // Clear badge and restore icon\n  chrome.action.setBadgeText({ text: \"\" });\n  chrome.action.setIcon({ path: chrome.runtime.getURL('icons/icon48.png') });\n  \n  // Clear the alarms\n  chrome.alarms.clear('badgeUpdate');\n  \n  // Close focus window if it exists\n  await closeFocusWindow();\n  \n  // Show end notification\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Session Ended',\n    message: `Great job! Your focus session has ended.`,\n  });\n  \n  // Release any links that were parked during the session\n  await releaseParkedLinks();\n}\n\n/**\n * Updates the badge text and color based on session state\n */\nfunction updateBadge(timeLeftMin: number, drifting: boolean) {\n  chrome.action.setBadgeBackgroundColor({\n    color: drifting ? \"#d32f2f\" : \"#1565c0\"  // red if drifting, blue otherwise\n  });\n  \n  chrome.action.setBadgeText({\n    text: timeLeftMin > 0 ? Math.ceil(timeLeftMin).toString() : \"\"\n  });\n  \n  chrome.action.setIcon({\n    path: drifting ? \n      chrome.runtime.getURL('icons/icon48.png') : // Would be focus_drift.png if it existed\n      chrome.runtime.getURL('icons/icon48.png')   // Would be focus_on.png if it existed\n  });\n}\n\n/**\n * Check if the user is currently drifting from focus\n */\nasync function checkIfDrifting(): Promise<boolean> {\n  const { focusSettings } = await getStorage([\"focusSettings\"]);\n  if (!focusSettings) return false;\n  \n  // For now, we'll just use a simple check based on the existing focus API\n  const response = await chrome.runtime.sendMessage({ type: \"CHECK_FOCUS_STATUS\" });\n  return response?.isLostFocus || false;\n}\n\n/**\n * Check if a focus session is currently active\n */\nexport async function isFocusSessionActive(): Promise<boolean> {\n  const focusState = await getFocusState();\n  return focusState.active;\n}\n\n/**\n * Returns how many seconds remain in the current focus session (if any)\n */\nexport async function getFocusSessionTimeLeft(): Promise<number> {\n  const focusState = await getFocusState();\n  if (!focusState.active || !focusState.endTime) return 0;\n\n  const now = Date.now();\n  const diff = focusState.endTime - now;\n  return diff > 0 ? diff / 1000 : 0;   // Return seconds, not minutes\n}\n\n/**\n * Determine if this URL is blocked under the current Focus Session settings.\n */\nexport async function isUrlBlocked(url: string, detectedCategory: string): Promise<boolean> {\n  const focusState = await getFocusState();\n\n  // If session not active, not blocked\n  if (!focusState.active) {\n    return false;\n  }\n\n  // If the context is not in allowed contexts, block it\n  if (detectedCategory && !focusState.allowedContexts.includes(detectedCategory)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Save current window's tab groups (workspace).\n * This can be called at the end of a Focus Session or on demand.\n */\nexport async function saveCurrentWorkspace(name: string): Promise<void> {\n  // Get all tab groups\n  const groups = await chrome.tabGroups.query({});\n  // For each group, gather tab URLs\n  const workspaceGroups = await Promise.all(\n    groups.map(async (grp) => {\n      const tabs = await chrome.tabs.query({ groupId: grp.id });\n      return {\n        groupId: grp.id,\n        title: grp.title || \"\",\n        color: grp.color,\n        tabUrls: tabs.map(t => t.url || \"\")\n      };\n    })\n  );\n\n  // Store in savedWorkspaces\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  const newWorkspaceEntry = {\n    name,\n    tabGroups: workspaceGroups,\n    timestamp: Date.now()\n  };\n\n  const updatedWorkspaces = Array.isArray(savedWorkspaces) \n    ? [...savedWorkspaces, newWorkspaceEntry]\n    : [newWorkspaceEntry];\n\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n}\n\n/**\n * Restore a saved workspace by name. \n * Re-open tabs and re-create groups (approximation).\n */\nexport async function restoreWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const workspace = savedWorkspaces.find(ws => ws.name === name);\n  if (!workspace) return;\n\n  // For each group, re-create tabs\n  for (const grp of workspace.tabGroups) {\n    // Open each tab\n    const tabIds = [];\n    for (const url of grp.tabUrls) {\n      const createdTab = await chrome.tabs.create({ url, active: false });\n      tabIds.push(createdTab.id as number);\n    }\n    // Create or update tab group\n    if (tabIds.length > 0) {\n      const newGroupId = await chrome.tabs.group({ tabIds });\n      await chrome.tabGroups.update(newGroupId, {\n        title: grp.title || \"\",\n        color: grp.color\n      });\n    }\n  }\n}\n\n/**\n * Clean up old workspace entries if needed, or remove a workspace by name, etc.\n */\nexport async function removeWorkspace(name: string): Promise<void> {\n  const { savedWorkspaces } = await getStorage([\"savedWorkspaces\"]);\n  if (!savedWorkspaces) return;\n\n  const updatedWorkspaces = savedWorkspaces.filter(ws => ws.name !== name);\n  await setStorage({ savedWorkspaces: updatedWorkspaces });\n} ","import { groupTabByContext, onTabRemoved, ungroupAllTabs } from \"../api/tabsApi\";\nimport { getStorage, setStorage, getFocusState, setFocusState } from \"../api/storageApi\";\nimport { checkFocusStatus, showFocusNotification } from \"../api/focusApi\";\nimport { restoreWorkspace } from \"../api/focusSessionManager\";\nimport { classifyPageContext } from \"../lib/contextEngine\";\nimport { extractDomain } from \"../lib/contextEngine/urlAnalyzer\";\nimport { saveForLater, releaseParkedLinks, goBackOrClose } from \"../api/parkedLinksApi\";\nimport * as focusEngine from \"../lib/focusEngine\";\n\nconst tabContextMap: Record<number, string> = {};\nconst BLOCKED_PAGE_URL = chrome.runtime.getURL(\"blocked.html\");\n\n/**\n * Initialize the extension with proper default settings\n */\nasync function initExtension(): Promise<void> {\n  // Use explicit defaults to avoid undefined behavior\n  const { \n    extensionEnabled = true,\n  } = await getStorage([\n    \"extensionEnabled\"\n  ]);\n  \n  console.log(`Initializing with state: ${JSON.stringify({ \n    extensionEnabled\n  })}`);\n  \n  // Check explicitly for true values\n  if (extensionEnabled === true) {\n    console.log(\"[Background] Extension enabled by user preference.\");\n    \n    // Check for active sessions - now using the new focusState\n    const focusState = await getFocusState();\n    if (focusState.active) {\n      console.log(\"[Background] Focus session was active at shutdown, verifying...\");\n      // Verify session is still valid (not expired)\n      if (!focusState.endTime || focusState.endTime <= Date.now()) {\n        console.log(\"[Background] Focus session expired during shutdown, cleaning up\");\n        await setFocusState({ active: false, endTime: undefined });\n      } else {\n        console.log(`[Background] Focus session continues until ${new Date(focusState.endTime).toLocaleTimeString()}`);\n      }\n    }\n  } else {\n    console.log(\"[Background] Extension disabled by user preference.\");\n  }\n  \n  // Setup URL blocking for Focus Session - always setup the handler\n  setupFocusSessionUrlBlocking();\n  \n  // Set up periodic checks\n  setupPeriodicChecks();\n}\n\n/**\n * Set up all periodic checks needed for the extension\n */\nfunction setupPeriodicChecks() {\n  // Periodic check for session end\n  setInterval(checkFocusSessionStatus, 30000); // check every 30s\n  \n  // More frequent check for focus loss during active sessions\n  setInterval(async () => {\n    try {\n      const isSessionActive = await focusEngine.isActive();\n      if (isSessionActive) {\n        const focusStatus = await checkFocusStatus();\n        if (focusStatus.isLostFocus) {\n          // Immediately send a drift warning if focus is lost\n          await sendDriftWarning(focusStatus);\n        }\n        // Update badge regardless\n        updateBadge();\n      }\n    } catch (err) {\n      console.error(\"Error in focus check interval:\", err);\n    }\n  }, 10000); // Check every 10 seconds during active sessions\n}\n\n/**\n * Handle messages from content scripts and the UI\n */\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.type === \"CONTEXT_UPDATE\" || request.type === \"CONTEXT_DETECTED\") {\n    const context = request.context as string;\n    const tabId = sender.tab?.id;\n    \n    if (tabId != null) {\n      // Check if context has changed\n      const previousContext = tabContextMap[tabId];\n      if (previousContext !== context) {\n        // Notify focus mode about context change\n        // handleContextChange(context);\n      }\n      \n      tabContextMap[tabId] = context;\n      \n      // Store additional context data if available\n      const contextData = {\n        context,\n        confidence: request.confidence,\n        secondaryContexts: request.secondaryContexts,\n        url: request.url\n      };\n      \n      // Save context data to storage for URL blocking functionality\n      chrome.storage.local.set({\n        [request.url]: { context: request.context, confidence: request.confidence }\n      });\n      \n      // Handle the context update\n      handleContextUpdate(tabId, context, contextData).catch((err) => console.error(err));\n    }\n    \n    return false; // No response needed\n  } \n  else if (request.type === \"FOCUS_TOGGLE\") {\n    toggleFocusMode(request.enabled).catch((err) => console.error(err));\n    return false; // No response needed\n  }\n  else if (request.type === \"START_FOCUS_SESSION\") {\n    const { durationMinutes, allowedContexts } = request.payload || {};\n    focusEngine.start(allowedContexts, durationMinutes)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Indicates async response\n  }\n  else if (request.type === \"END_FOCUS_SESSION\") {\n    focusEngine.end()\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(\"Error ending focus session:\", err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"GET_FOCUS_TIME_LEFT\") {\n    getFocusState()\n      .then(focusState => {\n        const seconds = focusState.endTime\n          ? Math.max(0, (focusState.endTime - Date.now()) / 1000)\n          : 0;\n        sendResponse({ seconds });\n      })\n      .catch(error => {\n        console.error(\"Error getting focus time left:\", error);\n        sendResponse({ seconds: 0 });\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"OVERRIDE_BLOCK\") {\n    // Allow explicit override\n    // Just respond with success, this would unblock the tab \n    // if we had a temporary block list\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"RESTORE_WORKSPACE\") {\n    const { name } = request.payload || {};\n    restoreWorkspace(name)\n      .then(() => sendResponse({ success: true }))\n      .catch((err) => {\n        console.error(err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true; // Indicates async response\n  }\n  else if (request.type === \"CHECK_FOCUS_STATUS\") {\n    checkFocusStatus()\n      .then(result => sendResponse(result))\n      .catch(error => {\n        console.error(\"Error checking focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  else if (request.type === \"CONTENT_SCRIPT_READY\") {\n    // Content script is ready to receive messages\n    const tabId = sender.tab?.id;\n    // if (tabId && activeTimer && activeTimer.active && activeTimer.endTime > Date.now()) {\n    //   console.log(`Tab ${tabId} is ready, sending active timer`);\n    //   // Send the timer right away\n    //   chrome.tabs.sendMessage(tabId, {\n    //     type: \"RESTORE_FOCUS_TIMER\",\n    //     timerState: activeTimer\n    //   }).catch(err => {\n    //     console.log('Tab not fully ready, will retry');\n    //     // Try again after a short delay\n    //     setTimeout(() => {\n    //       chrome.tabs.sendMessage(tabId, {\n    //         type: 'RESTORE_FOCUS_TIMER',\n    //         timerState: activeTimer\n    //       }).catch(err => console.error('Failed to restore timer after content script ready retry:', err));\n    //     }, 500);\n    //   });\n    // }\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"TIMER_EXPIRED\") {\n    // Handle timer expiration from the side panel\n    // endFocusTimer();\n    // Show a drift warning on the current page\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      if (tabs[0] && tabs[0].id) {\n        chrome.tabs.sendMessage(tabs[0].id, {\n          type: \"DRIFT_WARNING\",\n          message: \"Time's up! Return to your primary task now.\"\n        }, (resp) => {\n          if (chrome.runtime.lastError || resp === undefined) {\n            // Nobody listened - fall back to the blocked page\n            chrome.tabs.update(tabs[0].id!, {url: BLOCKED_PAGE_URL});\n          }\n        });\n      }\n    });\n    sendResponse({ success: true });\n    return true;\n  }\n  else if (request.type === \"PARK_LINK\") {\n    const { url, context, title } = request;\n    \n    // Handle the parked link asynchronously\n    (async () => {\n      try {\n        await saveForLater(url, context, title);\n        console.log(`[Parked Links] Saved for later: ${title || url} (${context})`);\n      } catch (error) {\n        console.error(\"Error parking link:\", error);\n      }\n    })();\n    \n    return false; // No response needed\n  }\n  else if (request.type === \"RELEASE_PARKED_LINKS\") {\n    // Handle the release of parked links asynchronously\n    (async () => {\n      try {\n        await releaseParkedLinks();\n        sendResponse({ success: true });\n      } catch (error) {\n        console.error(\"Error releasing parked links:\", error);\n        sendResponse({ success: false, error: String(error) });\n      }\n    })();\n    \n    return true; // Indicates async response\n  }\n  else if (request.type === \"TRAIN_CONTEXT\") {\n    (async () => {\n      const { url, title, actualContext, predictedContext, isFalsePositive } = request;\n      \n      // Get or create context data for this URL\n      const contextData = await getContextData(url);\n      \n      // Update training data\n      if (!contextData.training) {\n        contextData.training = {\n          falsePositives: [],\n          truePositives: []\n        };\n      }\n      \n      if (isFalsePositive) {\n        contextData.training.falsePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      } else {\n        contextData.training.truePositives.push({\n          timestamp: Date.now(),\n          actualContext,\n          predictedContext\n        });\n      }\n      \n      // Save updated context data\n      await saveContextData(url, contextData);\n      \n      // Recalculate context weights based on training data\n      await updateContextWeights(url);\n      \n      sendResponse({ success: true });\n    })();\n    return true; // Required for async response\n  }\n  else if (request.type === \"STAY_FOCUSED_ACTION\") {\n    (async () => {\n      const { url, context, title } = request.payload;\n      try {\n        await saveForLater(url, context, title);\n        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (tab?.id) await goBackOrClose(tab.id);\n        sendResponse({ success: true });\n      } catch (e: unknown) {\n        console.error(\"Stay‑focused flow failed:\", e);\n        sendResponse({ \n          success: false, \n          error: e instanceof Error ? e.message : String(e)\n        });\n      }\n    })();\n    return true;\n  }\n  else if (request.type === \"FOCUS_STATUS\") {\n    // Return the current focus state to the popup\n    getFocusState()\n      .then(focusState => sendResponse(focusState))\n      .catch(error => {\n        console.error(\"Error getting focus status:\", error);\n        sendResponse(null);\n      });\n    return true; // Required for async response\n  }\n  \n  return false; // No response needed for other messages\n});\n\n/**\n * Toggle focus mode on/off\n */\nasync function toggleFocusMode(enabled: boolean): Promise<void> {\n  if (enabled) {\n    // Just update badge in the new approach\n    updateBadge();\n  } else {\n    // Ungroup all tabs when focus mode is disabled\n    await ungroupAllTabs();\n    // Clear badge when focus mode is disabled\n    chrome.action.setBadgeText({ text: \"\" });\n  }\n}\n\n/**\n * Handle context update with enhanced data\n */\nasync function handleContextUpdate(\n  tabId: number, \n  context: string, \n  contextData?: any\n): Promise<void> {\n  // Get current settings\n  const { extensionEnabled, autoGroupEnabled = true } = await getStorage([\n    \"extensionEnabled\",\n    \"autoGroupEnabled\",\n  ]);\n\n  // If extension is disabled or auto-group is off, do nothing\n  if (extensionEnabled === false || autoGroupEnabled === false) {\n    return;\n  }\n\n  // Group tab by context\n  await groupTabByContext(tabId, context);\n  \n  // Update badge when context changes\n  updateBadge();\n}\n\n/**\n * Updates the badge with current context switch count\n */\nasync function updateBadge(): Promise<void> {\n  try {\n    // Update to use the new focusState instead of focusModeEnabled\n    const focusState = await getFocusState();\n    \n    // If focus mode is not active, don't show badge\n    if (!focusState.active) {\n      chrome.action.setBadgeText({ text: \"\" });\n      return;\n    }\n    \n    // Check if we're showing focus time or context switches\n    const focusTimeLeft = await focusEngine.getTimeLeft();\n    \n    if (focusTimeLeft > 0) {\n      // Convert seconds to minutes for badge\n      const minutesLeft = Math.ceil(focusTimeLeft / 60);\n      chrome.action.setBadgeText({ text: minutesLeft.toString() });\n      \n      // Get focus status to determine color\n      const focusStatus = await checkFocusStatus();\n      if (focusStatus.isLostFocus) {\n        chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red for lost focus\n      } else {\n        chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue for focused\n      }\n    } else {\n      // Show context switch count if no timer active\n      const focusStatus = await checkFocusStatus();\n      const switchCount = focusStatus.contextSwitches.length;\n      \n      // Set badge with context switch count\n      chrome.action.setBadgeText({ text: switchCount.toString() });\n      \n      // Change color if focus is lost\n      if (focusStatus.isLostFocus) {\n        chrome.action.setBadgeBackgroundColor({ color: \"#d32f2f\" }); // Red for lost focus\n      } else {\n        chrome.action.setBadgeBackgroundColor({ color: \"#1565c0\" }); // Blue for focused\n      }\n    }\n  } catch (error) {\n    console.error(\"Error updating badge:\", error);\n  }\n}\n\n/**\n * Send a high-visibility drift warning to the active tab\n */\nasync function sendDriftWarning(focusStatus: any): Promise<void> {\n  try {\n    // Always show warnings during focus sessions regardless of notification settings\n    // This is critical - users need to be alerted when drifting\n    \n    // Check if a focus session is active\n    const isSessionActive = await focusEngine.isActive();\n    if (!isSessionActive) {\n      return; // Only show drift warnings during active focus sessions\n    }\n    \n    console.log(\"[Focus] Sending drift warning to active tab\", focusStatus);\n    \n    // Get the active tab\n    const tabs = await chrome.tabs.query({active: true, currentWindow: true});\n    if (!tabs.length || !tabs[0].id) return;\n\n    const activeTab = tabs[0];\n    const tabId = activeTab.id as number;\n    \n    // Skip chrome:// pages and extension pages\n    if (\n      activeTab.url?.startsWith(\"chrome://\") || \n      activeTab.url?.startsWith(\"chrome-extension://\")\n    ) {\n      return;\n    }\n    \n    // Create a useful message about why focus was lost\n    let message = \"YOU'RE DRIFTING FROM YOUR FOCUS TASK!\";\n    \n    // If we have context switches, mention the last switch\n    if (focusStatus.contextSwitches.length > 0) {\n      const lastSwitch = focusStatus.contextSwitches[focusStatus.contextSwitches.length - 1];\n      message = `FOCUS LOST: Switched from ${lastSwitch.from} to ${lastSwitch.to}`;\n    }\n    \n    // Send the warning with callback to check if handled\n    chrome.tabs.sendMessage(tabId, {\n      type: \"DRIFT_WARNING\",\n      message\n    }, (resp) => {\n      if (chrome.runtime.lastError || resp === undefined) {\n        // Nobody listened - fall back to the blocked page\n        chrome.tabs.update(tabId, {url: BLOCKED_PAGE_URL});\n      }\n    });\n      \n    // Also show a system notification\n    chrome.notifications.create({\n      type: 'basic',\n      iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n      title: 'FOCUS ALERT!',\n      message: message,\n      priority: 2,\n      requireInteraction: true\n    });\n      \n    console.log(\"[Focus] Drift warning sent successfully\");\n  } catch (error) {\n    console.error(\"Error sending drift warning:\", error);\n  }\n}\n\n/**\n * Sets up URL blocking based on focus session\n */\nfunction setupFocusSessionUrlBlocking(): void {\n  // Listen for tab updates (URL changes)\n  chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\n    // Only check for URL changes\n    if (changeInfo.url && tab.url) {\n      try {\n        // Check if this URL should be blocked\n        const shouldBlock = await checkIfUrlShouldBeBlocked(tab.url);\n        if (shouldBlock) {\n          console.log(`[Focus] Blocking URL: ${tab.url}`);\n          \n          // Use standard BLOCKED_PAGE_URL for consistency with drift warnings\n          chrome.tabs.update(tabId, { url: BLOCKED_PAGE_URL });\n        }\n      } catch (error) {\n        console.error(\"Error checking URL:\", error);\n      }\n    }\n  });\n}\n\n/**\n * Check if URL should be blocked according to focus state and context\n */\nasync function checkIfUrlShouldBeBlocked(url: string): Promise<boolean> {\n  // Get the focus state\n  const focusState = await getFocusState();\n  \n  // If focus is not active, nothing is blocked\n  if (!focusState.active) {\n    return false;\n  }\n  \n  try {\n    // Classify the URL's context\n    const contextData = await getContextData(url);\n    const context = contextData?.context;\n    \n    if (!context) {\n      // If we can't determine the context, don't block\n      return false;\n    }\n    \n    // Use focusEngine to check if this context is blocked\n    return focusEngine.isBlocked(context);\n  } catch (error) {\n    console.error(\"Error classifying URL:\", error);\n    return false;\n  }\n}\n\n/**\n * Periodically check if a focus session should be ended\n */\nasync function checkFocusSessionStatus(): Promise<void> {\n  const timeLeft = await focusEngine.getTimeLeft();\n  if (timeLeft <= 0) {\n    const active = await focusEngine.isActive();\n    if (active) {\n      // Focus session time is up\n      await focusEngine.end();\n      console.log(\"[Focus] Session ended automatically due to timeout\");\n      \n      // Show notification to user\n      chrome.notifications.create({\n        type: 'basic',\n        iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n        title: 'Focus Session Complete',\n        message: `Your timed focus session has ended.`,\n      });\n    }\n  }\n}\n\n/**\n * Cleanup in-memory reference on tab removal\n */\nonTabRemoved((removedTabId) => {\n  delete tabContextMap[removedTabId];\n});\n\n// Function to get context data for a URL\nasync function getContextData(url: string): Promise<any> {\n  const result = await chrome.storage.local.get([url]);\n  return result[url] || { contexts: [], training: { falsePositives: [], truePositives: [] } };\n}\n\n// Function to save context data for a URL\nasync function saveContextData(url: string, data: any): Promise<void> {\n  await chrome.storage.local.set({ [url]: data });\n}\n\n// Function to update context weights based on training data\nasync function updateContextWeights(url: string): Promise<void> {\n  const contextData = await getContextData(url);\n  const { training } = contextData;\n  \n  if (!training) return;\n  \n  // Calculate weights based on false positives and true positives\n  const weights: { [key: string]: number } = {};\n  \n  // Decrease weight for contexts that frequently cause false positives\n  training.falsePositives.forEach((fp: any) => {\n    weights[fp.predictedContext] = (weights[fp.predictedContext] || 1) * 0.9;\n  });\n  \n  // Increase weight for contexts that are frequently true positives\n  training.truePositives.forEach((tp: any) => {\n    weights[tp.predictedContext] = (weights[tp.predictedContext] || 1) * 1.1;\n  });\n  \n  // Update context weights\n  contextData.weights = weights;\n  await saveContextData(url, contextData);\n}\n\n// Modify the tabs.onUpdated handler to remove timer-related code\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  // Check if the tab has completed loading\n  if (changeInfo.status === 'complete' && tab.url && !tab.url.startsWith('chrome://')) {\n    // Start a short delay to allow any content scripts to initialize\n    setTimeout(() => {\n      // Remove timer-related code\n      // if (activeTimer && activeTimer.active && activeTimer.endTime > Date.now()) {\n      //   // Target just this specific tab\n      //   chrome.scripting.executeScript({\n      //     target: { tabId },\n      //     func: () => {\n      //       // Force content script to re-check for timer\n      //       chrome.runtime.sendMessage({ type: \"CONTENT_SCRIPT_READY\" });\n      //     }\n      //   }).catch(err => {\n      //     // Ignore errors for restricted pages\n      //   });\n      //   \n      //   // Send the timer state to the newly loaded tab\n      //   chrome.tabs.sendMessage(tabId, {\n      //     type: 'RESTORE_FOCUS_TIMER',\n      //     timerState: activeTimer\n      //   }).catch(err => {\n      //     console.log('Tab not ready yet, will use script injection instead');\n      //     // Use script injection as fallback\n      //     ensureTimerVisibility();\n      //   });\n      // }\n    }, 500);\n  }\n});\n\n// Set default settings on installation/update\nchrome.runtime.onInstalled.addListener(details => {\n  if (details.reason === \"install\") {\n    // First-time install: set all features off by default\n    chrome.storage.local.set({\n      extensionEnabled: false,\n      autoGroupEnabled: true, // Set auto grouping enabled by default\n      focusState: {\n        active: false,\n        allowedContexts: []\n      },\n      firstRunComplete: false\n    });\n    \n    // Show onboarding page\n    chrome.tabs.create({ url: chrome.runtime.getURL(\"onboarding.html\") });\n  } else if (details.reason === \"update\") {\n    // Handle migration from old storage format to new\n    chrome.storage.local.get([\n      \"extensionEnabled\",\n      \"autoGroupEnabled\", // Also check for this setting\n      \"focusSessionActive\", \n      \"focusSessionEndTime\",\n      \"blockedCategories\",\n      \"focusState\"\n    ], result => {\n      // Migration: If we have old format data but no new focusState yet, convert it\n      if (!result.focusState && (result.focusSessionActive || result.blockedCategories)) {\n        console.log(\"Migrating from old focus session format to new focusState format\");\n        \n        // Convert to new FocusState format (invert the block logic to allowedContexts)\n        const knownContexts = [\n          \"Work\", \"Development\", \"Research\", \"Learning\", \n          \"Entertainment\", \"Social\", \"Shopping\", \"News\"\n        ];\n        \n        // Calculate allowed contexts by excluding blocked ones\n        const blockedCategories = result.blockedCategories || [];\n        const allowedContexts = knownContexts.filter(ctx => !blockedCategories.includes(ctx));\n        \n        const focusState = {\n          active: result.focusSessionActive === true,\n          allowedContexts,\n          endTime: result.focusSessionEndTime || undefined\n        };\n        \n        // Save the new format and clean up old keys\n        chrome.storage.local.set({ focusState }, () => {\n          // Remove old keys after migration\n          chrome.storage.local.remove([\n            \"focusSessionActive\", \n            \"focusSessionEndTime\", \n            \"blockedCategories\"\n          ]);\n        });\n      }\n      \n      // Ensure we have explicit boolean values, not undefined\n      const update: Record<string, any> = {};\n      if (result.extensionEnabled === undefined) update.extensionEnabled = false;\n      if (result.autoGroupEnabled === undefined) update.autoGroupEnabled = true;\n      \n      if (Object.keys(update).length > 0) {\n        chrome.storage.local.set(update);\n      }\n    });\n  }\n});\n\n// Kick off on load\ninitExtension().catch(console.error);","import { getStorage, setStorage } from \"./storageApi\";\nimport { ParkedLink } from \"../types/index\";\n\n/**\n * Save a link for later viewing\n */\nexport async function saveForLater(url: string, context: string, title?: string): Promise<void> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  \n  // Check if the URL is already parked to avoid duplicates\n  const isDuplicate = parkedLinks.some(link => link.url === url);\n  \n  if (!isDuplicate) {\n    const newLink: ParkedLink = {\n      url,\n      title,\n      context,\n      timestamp: Date.now()\n    };\n    \n    await setStorage({\n      parkedLinks: [...parkedLinks, newLink]\n    });\n  }\n}\n\n/**\n * Get all parked links\n */\nexport async function getParkedLinks(): Promise<ParkedLink[]> {\n  const { parkedLinks = [] } = await getStorage([\"parkedLinks\"]);\n  return parkedLinks;\n}\n\n/**\n * Open all parked links in new tabs and clear the list\n */\nexport async function releaseParkedLinks(): Promise<void> {\n  const parkedLinks = await getParkedLinks();\n  \n  if (parkedLinks.length === 0) {\n    return;\n  }\n  \n  // Create a new tab group for the parked links\n  const currentWindow = await chrome.windows.getCurrent();\n  let groupId: number | undefined;\n  \n  try {\n    // Open all the links in new tabs\n    const openedTabIds: number[] = [];\n    \n    for (const link of parkedLinks) {\n      const tab = await chrome.tabs.create({\n        url: link.url,\n        active: false\n      });\n      \n      if (tab.id) {\n        openedTabIds.push(tab.id);\n      }\n    }\n    \n    // Group the tabs if we have any\n    if (openedTabIds.length > 0) {\n      try {\n        groupId = await chrome.tabs.group({\n          tabIds: openedTabIds\n        });\n        \n        if (groupId) {\n          await chrome.tabGroups.update(groupId, {\n            title: \"Parked Links\",\n            color: \"blue\"\n          });\n        }\n      } catch (groupError) {\n        console.error(\"Error creating tab group:\", groupError);\n      }\n    }\n    \n    // Clear the parked links list\n    await setStorage({ parkedLinks: [] });\n    \n    // Show a notification\n    chrome.notifications.create({\n      type: \"basic\",\n      iconUrl: chrome.runtime.getURL(\"icons/icon48.png\"),\n      title: \"Parked Links Opened\",\n      message: `Opened ${parkedLinks.length} links that were saved during your focus session.`\n    });\n  } catch (error) {\n    console.error(\"Error opening parked links:\", error);\n  }\n}\n\n/**\n * More robust function to navigate back or close the current tab\n */\nexport async function goBackOrClose(tabId: number): Promise<void> {\n  try {\n    // Get tab info first to confirm it exists\n    const tab = await chrome.tabs.get(tabId);\n    \n    // First try to determine if we can go back using script injection\n    try {\n      const historyResults = await chrome.scripting.executeScript({\n        target: { tabId },\n        func: () => ({\n          canGoBack: window.history.length > 1,\n          url: window.location.href\n        })\n      });\n      \n      const { canGoBack } = historyResults[0].result;\n      \n      if (canGoBack) {\n        // Navigate back if possible using script injection\n        await chrome.scripting.executeScript({\n          target: { tabId },\n          func: () => window.history.back()\n        });\n        \n        // Success, we're done\n        return;\n      }\n      \n      // Can't go back, use fallback approach\n      await handleNavigationFallback(tabId, tab);\n    } catch (err) {\n      console.error(\"Script execution error:\", err);\n      \n      // Fallback to simpler chrome.tabs.goBack API\n      try {\n        await chrome.tabs.goBack(tabId);\n      } catch (backError) {\n        // If that fails too, use final fallback\n        await handleNavigationFallback(tabId, tab);\n      }\n    }\n  } catch (err) {\n    console.error(\"Tab lookup error:\", err);\n    // Tab might no longer exist, nothing to do\n  }\n}\n\n/**\n * Fallback navigation handler when going back isn't possible\n */\nasync function handleNavigationFallback(tabId: number, tab: chrome.tabs.Tab): Promise<void> {\n  try {\n    // Get all tabs in the window\n    const allTabs = await chrome.tabs.query({ windowId: tab.windowId });\n    \n    if (allTabs.length > 1) {\n      // More than one tab, find one to focus\n      const currentIndex = allTabs.findIndex(t => t.id === tabId);\n      const targetIndex = currentIndex > 0 ? currentIndex - 1 : (currentIndex + 1) % allTabs.length;\n      const targetTab = allTabs[targetIndex];\n      \n      // Focus the other tab first\n      if (targetTab.id) {\n        await chrome.tabs.update(targetTab.id, { active: true });\n        \n        // Then remove the current tab\n        setTimeout(() => {\n          chrome.tabs.remove(tabId).catch(e => {\n            console.error(\"Tab removal failed:\", e);\n          });\n        }, 100);\n      }\n    } else {\n      // Last tab, navigate to blank page instead\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    }\n  } catch (e) {\n    console.error(\"Navigation fallback failed:\", e);\n    // Last resort - try basic navigation\n    try {\n      await chrome.tabs.update(tabId, { url: \"about:blank\" });\n    } catch (finalError) {\n      console.error(\"Final fallback failed:\", finalError);\n    }\n  }\n}\n\n/**\n * Show a toast notification in the current tab\n */\nexport async function showToast(tabId: number, message: string, duration = 3000): Promise<void> {\n  try {\n    await chrome.scripting.executeScript({\n      target: { tabId },\n      func: (msg: string, dur: number) => {\n        const toast = document.createElement(\"div\");\n        toast.style.cssText = `\n          position: fixed;\n          bottom: 20px;\n          right: 20px;\n          background-color: rgba(0, 102, 204, 0.9);\n          color: white;\n          padding: 12px 20px;\n          border-radius: 4px;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n          font-family: Arial, sans-serif;\n          z-index: 2147483647;\n          max-width: 300px;\n          transition: opacity 0.3s ease-in-out;\n        `;\n        toast.textContent = msg;\n        document.body.appendChild(toast);\n        \n        // Fade out and remove\n        setTimeout(() => {\n          toast.style.opacity = \"0\";\n          setTimeout(() => toast.remove(), 300);\n        }, dur - 300);\n      },\n      args: [message, duration]\n    });\n  } catch (error) {\n    console.error(\"Error showing toast:\", error);\n  }\n}\n\n/**\n * Clear all parked links without opening them\n */\nexport async function clearParkedLinks(): Promise<void> {\n  await setStorage({ parkedLinks: [] });\n} ","import { pickColorForContext } from \"../lib/pickColor\";\n\nexport async function groupTabByContext(tabId: number, context: string): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  let existingGroup = groups.find((grp) => grp.title === context);\n\n  if (!existingGroup) {\n    // Create new group if none match\n    const newGroupId = await chrome.tabs.group({ tabIds: [tabId] });\n    existingGroup = await chrome.tabGroups.update(newGroupId, {\n      title: context,\n      color: pickColorForContext(context),\n    });\n  } else {\n    // Add to existing group\n    await chrome.tabs.group({ groupId: existingGroup.id, tabIds: [tabId] });\n  }\n}\n\nexport function onTabRemoved(callback: (tabId: number) => void): void {\n  chrome.tabs.onRemoved.addListener(callback);\n}\n\n/** Ungroup every tab in every window */\nexport async function ungroupAllTabs(): Promise<void> {\n  const groups = await chrome.tabGroups.query({});\n  for (const g of groups) {\n    const tabs = await chrome.tabs.query({ groupId: g.id });\n    if (tabs.length) {\n      await chrome.tabs.ungroup(tabs.map(t => t.id!));\n    }\n  }\n}","import { getStorage, setStorage } from \"./storageApi\";\nimport { FocusStatus, FocusSettings, ContextSwitch } from \"../types/index\";\n\nconst DEFAULT_FOCUS_SETTINGS: FocusSettings = {\n  enabled: true,\n  notificationsEnabled: true,\n  switchThreshold: 5,\n  timeWindowMinutes: 15\n};\n\n/**\n * Get the current focus settings\n */\nexport async function getFocusSettings(): Promise<FocusSettings> {\n  const { focusSettings } = await getStorage([\"focusSettings\"]);\n  return { ...DEFAULT_FOCUS_SETTINGS, ...focusSettings };\n}\n\n/**\n * Update focus settings\n */\nexport async function updateFocusSettings(settings: Partial<FocusSettings>): Promise<void> {\n  const currentSettings = await getFocusSettings();\n  await setStorage({ \n    focusSettings: { ...currentSettings, ...settings } \n  });\n}\n\n/**\n * Get context switches in a time window\n */\nexport async function getContextSwitches(timeWindowMinutes: number = 15): Promise<ContextSwitch[]> {\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (!contextHistory || contextHistory.length < 2) {\n    return [];\n  }\n  \n  const switches: ContextSwitch[] = [];\n  const now = Date.now();\n  const timeWindow = timeWindowMinutes * 60 * 1000;\n  \n  // Filter history to time window\n  const relevantHistory = contextHistory.filter(\n    entry => (now - entry.timestamp) < timeWindow\n  );\n  \n  // Find context switches\n  for (let i = 1; i < relevantHistory.length; i++) {\n    if (relevantHistory[i].context !== relevantHistory[i-1].context) {\n      switches.push({\n        from: relevantHistory[i-1].context,\n        to: relevantHistory[i].context,\n        timestamp: relevantHistory[i].timestamp,\n        fromUrl: relevantHistory[i-1].url,\n        toUrl: relevantHistory[i].url\n      });\n    }\n  }\n  \n  return switches;\n}\n\n/**\n * Check if focus is lost based on context switching\n */\nexport async function checkFocusStatus(): Promise<FocusStatus> {\n  const settings = await getFocusSettings();\n  const switches = await getContextSwitches(settings.timeWindowMinutes);\n  \n  let currentContext = \"Unknown\";\n  let currentStreak = 1;\n  \n  // Get most recent context and streak\n  const { contextHistory } = await getStorage([\"contextHistory\"]);\n  if (contextHistory && contextHistory.length > 0) {\n    currentContext = contextHistory[contextHistory.length - 1].context;\n    \n    // Count consecutive entries with same context\n    let i = contextHistory.length - 1;\n    while (i > 0 && contextHistory[i].context === currentContext) {\n      currentStreak++;\n      i--;\n    }\n  }\n  \n  // Determine if focus is lost\n  const isLostFocus = switches.length >= settings.switchThreshold;\n  \n  return {\n    isLostFocus,\n    contextSwitches: switches,\n    currentStreak,\n    currentContext\n  };\n}\n\n/**\n * Show focus notification\n */\nexport function showFocusNotification(contextSwitches: ContextSwitch[]): void {\n  chrome.notifications.create({\n    type: 'basic',\n    iconUrl: chrome.runtime.getURL('icons/icon48.png'),\n    title: 'Focus Alert',\n    message: `You've switched contexts ${contextSwitches.length} times recently. Try to maintain focus.`,\n    buttons: [\n      { title: 'View Details' }\n    ]\n  });\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(545);\n"],"names":["getStorage","keys","Promise","resolve","reject","chrome","storage","local","get","result","runtime","lastError","setStorage","data","set","async","getFocusState","focusState","active","allowedContexts","context","url","confidence","contextHistory","newHistory","push","timestamp","Date","now","length","shift","partialState","currentState","focusWindowId","launchFocusWindow","undefined","windows","error","id","create","type","state","tabs","query","windowId","update","getURL","console","remove","tabId","move","index","blockClearTimer","endTimeCheckInterval","recentlyBlocked","end","setFocusState","endTime","action","setBadgeText","text","clearInterval","clearTimeout","allowed","durationMin","setBadgeBackgroundColor","color","setInterval","log","notifications","iconUrl","title","message","priority","includes","setTimeout","timeLeftMs","Math","max","floor","currentWindow","getCurrent","sidePanel","open","panels","getAll","all","map","panel","close","path","setOptions","enabled","alarmListenerRegistered","updateBadge","timeLeftMin","drifting","ceil","toString","setIcon","getFocusSessionTimeLeft","diff","saveCurrentWorkspace","name","groups","tabGroups","workspaceGroups","grp","groupId","tabUrls","t","savedWorkspaces","newWorkspaceEntry","updatedWorkspaces","Array","isArray","durationMinutes","blockedCategories","filter","ctx","openSidePanel","alarms","periodInMinutes","onAlarm","addListener","alarm","focusSettings","response","sendMessage","isLostFocus","checkIfDrifting","focusWindowEnabled","saveWorkspace","workspaceName","closeSidePanel","ungroupAllTabs","clear","closeFocusWindow","releaseParkedLinks","detectedCategory","workspace","find","ws","tabIds","createdTab","newGroupId","group","tabContextMap","BLOCKED_PAGE_URL","focusTimeLeft","focusEngine","getTimeLeft","minutesLeft","checkFocusStatus","focusStatus","switchCount","contextSwitches","checkFocusSessionStatus","isActive","getContextData","contexts","training","falsePositives","truePositives","saveContextData","onMessage","request","sender","sendResponse","tab","secondaryContexts","extensionEnabled","autoGroupEnabled","groupTabByContext","handleContextUpdate","catch","err","toggleFocusMode","payload","start","then","success","seconds","restoreWorkspace","resp","saveForLater","String","actualContext","predictedContext","isFalsePositive","contextData","weights","forEach","fp","tp","updateContextWeights","goBackOrClose","e","Error","onTabRemoved","removedTabId","onUpdated","changeInfo","status","startsWith","onInstalled","details","reason","firstRunComplete","focusSessionActive","knownContexts","focusSessionEndTime","Object","JSON","stringify","toLocaleTimeString","isBlocked","checkIfUrlShouldBeBlocked","activeTab","lastSwitch","from","to","requireInteraction","sendDriftWarning","initExtension","getParkedLinks","parkedLinks","handleNavigationFallback","allTabs","currentIndex","findIndex","targetTab","finalError","some","link","newLink","openedTabIds","groupError","historyResults","scripting","executeScript","target","func","canGoBack","window","history","location","href","back","goBack","backError","duration","msg","dur","toast","document","createElement","style","cssText","textContent","body","appendChild","opacity","args","existingGroup","pickColorForContext","callback","onRemoved","g","ungroup","DEFAULT_FOCUS_SETTINGS","notificationsEnabled","switchThreshold","timeWindowMinutes","getFocusSettings","getContextSwitches","switches","timeWindow","relevantHistory","entry","i","fromUrl","toUrl","settings","currentSettings","currentContext","currentStreak","buttons","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}